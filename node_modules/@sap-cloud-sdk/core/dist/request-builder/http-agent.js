"use strict";
/* Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved. */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var http = __importStar(require("http"));
var https = __importStar(require("https"));
var util_1 = require("@sap-cloud-sdk/util");
var rambda_1 = require("rambda");
var proxy_util_1 = require("../util/proxy-util");
var logger = util_1.createLogger({
    package: 'core',
    messageContext: 'http-agent'
});
/**
 * Returns the http or https-agent config depending on the destination URL.
 * If the destination contains a proxy configuration, the agent will be a proxy-agent.
 * If not it will be the default http-agent coming from node.
 *
 * @param destination - determining which kind of configuration is returned
 * @returns The http or http-agent configuration.
 */
function getAgentConfig(destination) {
    var agentType = destination.proxyConfiguration ? AgentType.PROXY : AgentType.DEFAULT;
    if (agentType === AgentType.PROXY) {
        return createProxyAgent(destination);
    }
    return createDefaultAgent(destination);
}
exports.getAgentConfig = getAgentConfig;
var AgentType;
(function (AgentType) {
    AgentType[AgentType["DEFAULT"] = 0] = "DEFAULT";
    AgentType[AgentType["PROXY"] = 1] = "PROXY";
})(AgentType || (AgentType = {}));
function createProxyAgent(destination) {
    if (!destination.proxyConfiguration) {
        throw new Error("The destination proxy configuration: " + destination.proxyConfiguration + " is undefined.");
    }
    if (destination.isTrustingAllCertificates) {
        logger.warn('The destination is configured to both use a proxy and to trust all certificates. This is currently not supported. The proxy configuration will be applied, but certificates will be validated.');
    }
    return proxy_util_1.proxyAgent(destination);
}
var trustAllOptions = function (destination) { return function (options) {
    return rambda_1.assoc('rejectUnauthorized', !destination.isTrustingAllCertificates, options);
}; };
var certificateOptions = function (destination) { return function (options) {
    if (destination.keyStoreName && destination.keyStorePassword) {
        var certificate = selectCertificate(destination);
        return __assign(__assign({}, options), { pfx: Buffer.from(certificate.content, 'base64'), passphrase: destination.keyStorePassword });
    }
    return options;
}; };
var supportedCertificateFormats = ['p12', 'pfx'];
function hasSupportedFormat(certificate) {
    var certificateFormat = rambda_1.last(certificate.name.split('.'));
    if (certificateFormat) {
        return supportedCertificateFormats.includes(certificateFormat);
    }
    return false;
}
function selectCertificate(destination) {
    var certificate = destination.certificates.find(function (c) { return c.name === destination.keyStoreName; });
    if (!certificate) {
        throw Error("No certificate with name " + destination.keyStoreName + " could be found on the destination!");
    }
    if (!hasSupportedFormat(certificate)) {
        var format = rambda_1.last(certificate.name.split('.'));
        throw Error("The format of the provided certificate " + certificate.name + " is not supported. Supported formats are: " + supportedCertificateFormats.join(', ') + ". " + (format && ['jks', 'keystore'].includes(format)
            ? "You can convert Java Keystores (.jks, .keystore) into PKCS#12 keystores using the JVM's keytool CLI: keytool -importkeystore -srckeystore your-keystore.jks -destkeystore your-keystore.p12 -deststoretype pkcs12"
            : ''));
    }
    return certificate;
}
function createDefaultAgent(destination) {
    if (getProtocolOrDefault(destination) === Protocol.HTTPS) {
        if (destination.isTrustingAllCertificates) {
            logger.warn('"isTrustingAllCertificates" property in the provided destination is set to "true". This is highly discouraged in production.');
        }
        var options = rambda_1.pipe(trustAllOptions(destination), certificateOptions(destination))({});
        return { httpsAgent: new https.Agent(options) };
    }
    if (destination.isTrustingAllCertificates) {
        logger.warn('"isTrustingAllCertificates" is not available for HTTP.');
    }
    return { httpAgent: new http.Agent() };
}
/**
 * Extracts the http protocol from the destination url. The default value is http if no protocol is given.
 *
 * @param destination - URL of this destination is parsed
 * @throws Error in case a unsupported protocol is given in the destination URL like rfc://example.com.
 * @returns The protocol, either https or http.
 */
function getProtocolOrDefault(destination) {
    var _a, _b, _c;
    var protocol = (_c = (_b = (_a = destination) === null || _a === void 0 ? void 0 : _a.url) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === null || _c === void 0 ? void 0 : _c.split('://');
    if (!protocol || protocol.length === 1) {
        logger.warn("URL of the provided destination (" + destination.url + ") has no protocol specified! Assuming HTTPS.");
        return Protocol.HTTPS;
    }
    var casted = Protocol.of(protocol[0]);
    if (casted) {
        return casted;
    }
    throw new Error("Protocol of the provided destination (" + destination.url + ") is not supported! Currently only HTTP and HTTPS are supported.");
}
exports.getProtocolOrDefault = getProtocolOrDefault;
/**
 * @deprecated Since v1.5.1. use getProtocolOrDefault instead
 * Takes the destination URL and return everything before the '://'.
 *
 * @param destination - URL of this destination is parsed
 * @returns The protocol either undefined if no :// is found or anything before the delimiter.
 */
function getUrlProtocol(destination) {
    if (destination.url) {
        var urlParts = destination.url.toLowerCase().split('://');
        if (urlParts.length > 1) {
            return urlParts[0];
        }
    }
}
exports.getUrlProtocol = getUrlProtocol;
/**
 * Protocol enumeration, either 'http' or 'https'.
 */
var Protocol;
(function (Protocol) {
    Protocol["HTTP"] = "http";
    Protocol["HTTPS"] = "https";
})(Protocol = exports.Protocol || (exports.Protocol = {}));
/* eslint-disable-next-line no-redeclare */
(function (Protocol) {
    /**
     * Get [[Protocol]] from its string representation.
     * @param protocol Protocol as string, either 'http' or 'https'.
     * @returns Either the matching protocol or undefined
     */
    function of(protocol) {
        if (protocol.toLowerCase() === Protocol.HTTP) {
            return Protocol.HTTP;
        }
        if (protocol.toLowerCase() === Protocol.HTTPS) {
            return Protocol.HTTPS;
        }
    }
    Protocol.of = of;
})(Protocol = exports.Protocol || (exports.Protocol = {}));
//# sourceMappingURL=http-agent.js.map