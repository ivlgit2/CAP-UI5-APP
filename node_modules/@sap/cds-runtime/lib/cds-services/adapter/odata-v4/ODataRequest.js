/* istanbul ignore file */

const uuid = require('../../../common/utils/uuid')

const { Request, User } = require('@sap/cds')

const MODEL = Symbol.for('sap.cds.model')
const { COMMON, ODATA } = require('../../../common/constants/annotation')

const odataToCQN = require('./odata-to-cqn/odataToCQN')
const { getData, getParams } = require('./utils/data')
const { statements } = require('../../index')

// REVISIT: replace with Error Class (Information Class as well?) -> error codes, customization, i18n, etc.
const getError = require('../../util/getError')

function _getTarget (entities, segments) {
  const last = segments.pop()
  if (!last) return
  if (last.getEdmType() && last.getEdmType().csdlStructuredType) {
    const name = last.getEdmType().csdlStructuredType.name
    // TODO: better way to identify situation "view with parameters"
    return entities[name] || (name.endsWith('Parameters') && entities[name.replace(/Parameters$/, '')])
  }
  return _getTarget(entities, segments)
}

function _isDraftEntity (target) {
  return target && (target[ODATA.DRAFT] || target[COMMON.DRAFT_NODE.PREP_ACTION])
}

function _targetNeedsProxyForDraft (target, type, data, req) {
  if (!_isDraftEntity(target) || type === 'READ' || data.IsActiveEntity === 'true') return false
  if ((req.getUriInfo().getLastSegment() && req.getUriInfo().getLastSegment().getKind()) !== 'BOUND.ACTION') return true
  if (!['draftPrepare', 'draftActivate'].includes(req.getUriInfo().getLastSegment().getAction().getName())) return false
  return true
}

/*
 * Class representing an OData request.
 * @extends Request
 *
 * @param {String} type - The OData request type (a.k.a. "Component")
 * @param {Object} service - The underlying CAP service
 * @param {Object} req - OKRA's req
 * @param {Object} res - OKRA's res
 */
class ODataRequest extends Request {
  constructor (type, service, req, res) { // NOSONAR
    const _ = {
      req: req.getIncomingRequest(),
      res: req.getIncomingRequest().res
    }

    /*
     * data
     */
    const data = getData(type, service, req)

    /*
     * target
     */
    let target = _getTarget(service.entities, [...req.getUriInfo().getPathSegments()])

    /*
     * query
     */
    // REVISIT: remove usage of req._.returnType
    let operation = req.getUriInfo().getLastSegment() && req.getUriInfo().getLastSegment().getKind()
    switch (operation) {
      case 'BOUND.ACTION':
      case 'ACTION.IMPORT':
      case 'BOUND.FUNCTION':
      case 'FUNCTION.IMPORT':
        _.returnType = target
        break
      default:
        operation = type
    }
    const query = odataToCQN(operation, service, { statements, target, data, _ }, req)
    // REVISIT: should query._target be used?
    query._target = target

    /*
     * event
     */
    let event = type
    // actions & functions
    switch (req.getUriInfo().getLastSegment() && req.getUriInfo().getLastSegment().getKind()) {
      case 'BOUND.ACTION':
        event = req.getUriInfo().getLastSegment().getAction().getName()
        break
      case 'ACTION.IMPORT':
        event = `${service.name}.${req.getUriInfo().getLastSegment().getActionImport().getName()}`
        break
      case 'BOUND.FUNCTION':
        event = req.getUriInfo().getLastSegment().getFunction().getName()
        break
      case 'FUNCTION.IMPORT':
        event = `${service.name}.${req.getUriInfo().getLastSegment().getFunctionImport().getName()}`
        break
      default:
      // nothing to do
    }
    // draft
    if (_isDraftEntity(target)) {
      if (type === 'CREATE') event = 'NEW'
      else if (event === 'draftEdit') event = 'EDIT'
      else if (type === 'UPDATE') event = 'PATCH'
      else if (type === 'DELETE' && data.IsActiveEntity !== 'true') event = 'CANCEL'
    }

    /*
     * adjust target for draft
     * note: must be done after assignment to _.returnType (and query._target?)
     */
    // REVISIT: better not and why via proxy?
    if (_targetNeedsProxyForDraft(target, type, data, req)) {
      target = new Proxy(target, {
        get: (obj, prop) => (prop === 'name' || prop === '@cds.persistence.name' ? `${obj.name}_drafts` : obj[prop])
      })
    }

    /*
     * user
     */
    // REVISIT: align roles determination with cds.User
    const _roles = {
      any: true,
      'identified-user': !!(_.req.user && _.req.user.id),
      'authenticated-user': !!(_.req.user && _.req.user.id) && !!(_.req.authInfo && _.req.authInfo.grantType)
    }
    if (_.req.authInfo && _.req.authInfo.scopes) {
      _.req.authInfo.scopes.forEach(scope => (_roles[scope] = true))
      // REVISIT: is system-user documented?
      if (['client_credentials', 'client_x509'].includes(_.req.authInfo.grantType) && !_.req.authInfo.scopes.includes('system-user')) {
        _roles['system-user'] = true
      }
    }
    const authInfo = {}
    if (_.req.authInfo) {
      authInfo.attr = _.req.authInfo.userAttributes
      // REVISIT: cds.User.tenant not assignable
      // authInfo.tenant = _.req.authInfo.identityZone
    }
    const user = new User(Object.assign({ req: _.req, _roles }, _.req.user || { id: 'anonymous' }, authInfo))

    /*
     * super
     */
    super({ event, target, data, query, user, _ })

    /*
     * req.params
     */
    Object.defineProperty(this, 'params', {
      configurable: true,
      get: function () {
        this._params = this._params || getParams(this._.odataReq)
        return this._params
      }
    })

    // REVISIT: streamline ref to model
    this[MODEL] = service.model

    // REVISIT: _txId and _.shared needed for transaction handling in legacy Service
    this._txId = req.getAtomicityGroupId() || uuid()
    this._.shared = req.getBatchApplicationData() || {}

    // REVISIT: odataReq and odataRes should not be needed during request processing
    this._.odataReq = req
    this._.odataRes = res

    // REVISIT: context.statements to be removed (cf. https://github.wdf.sap.corp/cap/matters/issues/837)
    this.statements = statements

    // REVISIT: add .has to cds.User or remove .has usage
    user.has = roles => roles.some(role => user.is(role))

    // REVISIT: remove (req.attr not documented)
    this.attr = _.req.authInfo
  }

  /*
   * ...
   * @param {Number} [code] - ...
   * @param {(String|Object)} msg - ...
   * @param {String} [target] - Property of entity to which the info relates (e.g., `name` or a navigation path).
   */
  // REVISIT signature for @sap/cds@4.0.0
  info (code, msg, target) {
    if (!this._.infos) this._.infos = []
    // TODO: adjust to info
    const info = getError(code, msg, target)
    this._.infos.push(info)
    return info
  }

  /*
   * The following are currently added during processEvent.
   * - .error and .reject: different signature than in cds.Request, so we'll need to decorate for cds.Service.
   * - .diff: TBD
   */

  // /*
  //  * ...
  //  * @param {Number} [code] - ...
  //  * @param {(String|Object|Error)} msg - ...
  //  * @param {String} [target] - Property of entity to which the error relates (e.g., `name` or a navigation path).
  //  */
  // // REVISIT signature for @sap/cds@4.0.0
  // error (code, msg, target) {
  //   const error = getError(code, msg, target)
  //   this.errors.push(error)
  //   return error
  // }

  // /*
  //  * ...
  //  * @param {Number} [code] - ...
  //  * @param {(String|Object|Error)} msg - ...
  //  * @param {String} [target] - Property of entity to which the error relates (e.g., `name` or a navigation path).
  //  */
  // // REVISIT signature for @sap/cds@4.0.0
  // reject (code, msg, target) {
  //   this.rejected = getError(code, msg, target)
  // }

  // /*
  //  * ...
  //  * @param {(Array|Object)} data - ...
  //  */
  // // REVISIT: req.diff() or srv.diff()? -> remove with @sap/cds@4.0.0?
  // // REVISIT: may data be array?
  // diff (data) {
  //   return this.service.diff(this, data)
  // }
}

module.exports = ODataRequest
