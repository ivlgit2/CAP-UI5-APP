const { COMMON, ODATA } = require('../../../../common/constants/annotation')

const BaseContext = require('../../utils/BaseContext')
const getError = require('../../../util/getError')

const {
  Components: {
    ACTION_EXECUTE_HANDLER,
    DATA_DELETE_HANDLER,
    DATA_READ_HANDLER,
    DATA_CREATE_HANDLER,
    DATA_UPDATE_HANDLER
  }
} = require('@sap/odata-server')

const { getData, getParams } = require('./data')

const { isCustomOperation } = require('./request')
const odataToCQN = require('../odata-to-cqn/odataToCQN')
const { isViewWithParamSegments } = require('../odata-to-cqn/selectHelper')

const isDraftEntity = target => target[ODATA.DRAFT] || target[COMMON.DRAFT_NODE.PREP_ACTION]

const _proxifyForDraftsName = target => {
  const draftName = `${target.name}_drafts`
  const entityProxyHandler = {
    // TODO: persistence name could be set via annotations or uppercase
    get: (obj, prop) => (prop === 'name' || prop === '@cds.persistence.name' ? draftName : obj[prop])
  }
  return new Proxy(target, entityProxyHandler)
}

const _cancelOrDelete = (target, data) => {
  return (target[ODATA.DRAFT] || target[COMMON.DRAFT_NODE.PREP_ACTION]) && data.IsActiveEntity !== 'true'
    ? 'CANCEL'
    : 'DELETE'
}

/**
 * Gets the name of the service entity targeted by the given navigation path.
 * Undefined in case of a function or action import.
 * @param {Service} service
 * @param {Array} pathSegments - The path segments of a uri.
 * @returns {string} - The name of the navigation target entity.
 * @private
 */
const _getTargetEntityName = (service, pathSegments) => {
  if (isCustomOperation(pathSegments, false)) {
    return undefined
  }

  let navSegmentName
  const pathSegment = pathSegments[0]
  let entityName = `${service.name}.${(pathSegment.getEntitySet() || pathSegment.getSingleton()).getName()}`

  // special case of view with parameter, no navigation needed
  /* istanbul ignore if */
  if (isViewWithParamSegments(pathSegments)) {
    return entityName
  }

  for (const navSegment of pathSegments.filter(segment => segment.getNavigationProperty() !== null)) {
    navSegmentName = navSegment.getNavigationProperty().getName()
    entityName =
      navSegmentName === 'DraftAdministrativeData'
        ? service.entities[navSegmentName].name
        : service.model.definitions[entityName].elements[navSegmentName].target
  }

  return entityName
}

const _newOrCreate = target => {
  return target[ODATA.DRAFT] || target[COMMON.DRAFT_NODE.PREP_ACTION] ? 'NEW' : 'CREATE'
}

const _patchOrUpdate = target => {
  return target[ODATA.DRAFT] || target[COMMON.DRAFT_NODE.PREP_ACTION] ? 'PATCH' : 'UPDATE'
}

const _readOrOperation = (pathSegments, target) => {
  if (isCustomOperation(pathSegments)) {
    const invokedFunction = pathSegments[pathSegments.length - 1].getFunction()
    return target ? invokedFunction.getName() : invokedFunction.getFullQualifiedName().toString()
  }
  return 'READ'
}

const _definedNameOrEdit = (target, pathSegments, service) => {
  const lastSegment = pathSegments[pathSegments.length - 1].getAction().getName()

  if (target) {
    return lastSegment === 'draftEdit' ? 'EDIT' : lastSegment
  }

  return `${service.name}.${lastSegment}`
}

const _getEvent = ({ component, pathSegments, target, data, service }) => {
  switch (component) {
    case DATA_CREATE_HANDLER:
      return _newOrCreate(target)
    case DATA_UPDATE_HANDLER:
      return _patchOrUpdate(target)
    case DATA_DELETE_HANDLER:
      return _cancelOrDelete(target, data)
    case DATA_READ_HANDLER:
      return _readOrOperation(pathSegments, target)
    case ACTION_EXECUTE_HANDLER:
      return _definedNameOrEdit(target, pathSegments, service)
  }
}

const _getActionOrFunctionReturnType = (pathSegments, definitions) => {
  if (!isCustomOperation(pathSegments, true)) {
    return undefined
  }

  const actionOrFunction =
    pathSegments[pathSegments.length - 1].getFunction() || pathSegments[pathSegments.length - 1].getAction()
  if (actionOrFunction) {
    const returnType = actionOrFunction.getReturnType()
    if (returnType) {
      // eslint-disable-next-line standard/computed-property-even-spacing
      return definitions[
        returnType
          .getType()
          .getFullQualifiedName()
          .toString()
      ]
    }
  }
}

class OdataContext extends BaseContext {
  constructor (component, service, req, res, noProxyTarget = false) {
    super(service, req.getAtomicityGroupId())

    const pathSegments = req.getUriInfo().getPathSegments()
    const definitions = service.model.definitions
    const target = definitions[_getTargetEntityName(service, pathSegments)]
    this._ = this._getUnderscore(req, res)
    this._.returnType = _getActionOrFunctionReturnType(pathSegments, definitions)

    this.setHttpMethod(req.getMethod())

    this.setUserAndAttr(service)

    this.data = getData(component, service, req, target)

    this.target =
      !noProxyTarget && target && isDraftEntity(target) && this.data.IsActiveEntity !== 'true'
        ? _proxifyForDraftsName(target)
        : target

    this.event = _getEvent({ component, pathSegments, target: this.target, data: this.data, service })

    this.info = (code, msg, target) => {
      this._.infos = this._.infos || []

      const infoObj = getError(code, msg, target)
      this._.infos.push(infoObj)

      return infoObj
    }

    Object.defineProperty(this, 'query', {
      configurable: true,
      get: function () {
        const query = odataToCQN(isCustomOperation(pathSegments) || component, service, this, req)
        Object.defineProperty(this, 'query', { value: query, writable: true })
        return query
      },
      set: function (value) {
        Object.defineProperty(this, 'query', { value: value, writable: true })
      }
    })

    // REVISIT: remove istanbul ignore once overwrite in umbrella is gone
    Object.defineProperty(this, 'params', {
      configurable: true,
      get: /* istanbul ignore next */ function () {
        this._params = this._params || getParams(this._.odataReq)
        return this._params
      }
    })

    this.postPreparation(req.getIncomingRequest())

    const atomicityGroupId = req.getAtomicityGroupId()
    if (atomicityGroupId) {
      this.setStore(this._.shared.eventEmitterOfAtomicityGroup.get(atomicityGroupId))
    }
  }

  /**
   * In case of batch request use the applicationData object as base,
   * else create a new object.
   * @param {Object} req - odata-v4 request object.
   * @param {Object} res - odata-v4 response object.
   * @return {Object}
   * @private
   */
  _getUnderscore (req, res) {
    const _ = {}
    _.shared = req.getBatchApplicationData()

    // Not batched, create object, that can be shared later on and will hold channel specifc details in any case.
    if (!_.shared) {
      _.shared = {}
    }

    _.odataReq = req
    _.odataRes = res

    // Give the app developer access to the original (express) request object
    if (!_.req) {
      _.req = req.getBatchApplicationData() ? _.shared.req : req.getIncomingRequest()
      _.res = _.req.res
    }

    return _
  }
}

module.exports = OdataContext
