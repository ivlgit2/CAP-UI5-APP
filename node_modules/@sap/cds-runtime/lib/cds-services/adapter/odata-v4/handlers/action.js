const {
  Components: { ACTION_EXECUTE_HANDLER }
} = require('@sap/odata-server')

const OdataContext = require('../utils/OdataContext')
const ODataRequest = process.env.CDS_FEATURES_NONG ? require('../ODataRequest') : Object

const setSapMessageHeader = require('../utils/sap-message-header')
const { toODataResult } = require('../utils/event')
const { validateResourcePath } = require('../utils/request')

const _getLastSegment = req => {
  const pathSegments = req.getUriInfo().getPathSegments()
  return pathSegments[pathSegments.length - 1].getAction().getName()
}

/*
 * Get the returns object for the (un)bound action from CSN.
 */
const _getTypeReturns = (definitions, context, service) => {
  if (context.event === 'draftPrepare' || context.event === 'EDIT' || context.event === 'draftActivate') {
    return 'Other'
  }

  if (
    context.target &&
    context._.odataReq
      .getUriInfo()
      .getLastSegment()
      .getKind() === 'BOUND.ACTION'
  ) {
    return definitions[context.target.name].actions[context.event].returns
  }

  // Also support correct req.event without service prefix
  return (definitions[context.event] || definitions[service.name +'.'+ context.event]).returns
}

/*
 * Check if the return is an array or any other.
 */
const _getActionReturnType = (service, context) => {
  const returns = _getTypeReturns(service.model.definitions, context, service)

  return returns && returns.items ? 'Array' : 'Other'
}

/**
 * Check the CSN which type needs to be returned.
 * If the result is not of this type, convert.
 * @param {string} returnType
 * @param {*} result
 * @returns {string|Object}
 * @private
 */
const _convertResult = (returnType, result) => {
  if (!Array.isArray(result) && returnType === 'Array') {
    return toODataResult([result])
  }

  if (Array.isArray(result) && returnType !== 'Array') {
    return toODataResult(result[0])
  }

  return toODataResult(result)
}

/**
 * The handler that will be registered with odata-v4.
 * @param {Service} service
 * @param {Object} options
 * @return {Function}
 */
const action = (service, options) => {
  return (req, res, next) => {
    // End here if length is greater then allowed
    validateResourcePath(req, options, service.model)

    let context
    if (process.env.CDS_FEATURES_NONG) {
      context = new ODataRequest(ACTION_EXECUTE_HANDLER, service, req, res)
    } else {
      const lastSegment = _getLastSegment(req)
      const noProxyTarget = !['draftPrepare', 'draftActivate'].includes(lastSegment)
      context = new OdataContext(ACTION_EXECUTE_HANDLER, service, req, res, noProxyTarget)
    }

    service
      .processEvent(context)
      .then(result => {
        if (req.getConcurrentResource() !== null) {
          const etagElement = Object.values(context.target.elements).find(element => {
            return element['@odata.etag']
          })

          if (result && result[etagElement.name]) {
            result['*@odata.etag'] = result[etagElement.name]
          }
        }

        setSapMessageHeader(res, context._.infos)
        context.emit('succeeded')
        context.emit('done')
        next(null, _convertResult(_getActionReturnType(service, context), result))
      })
      .catch(err => {
        context.emit('failed', err)
        setSapMessageHeader(res, context._.infos)
        context.emit('done')
        next(err)
      })
  }
}

module.exports = action
