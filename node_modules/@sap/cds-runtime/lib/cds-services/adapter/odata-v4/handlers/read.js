const {
  QueryOptions,
  Components: { DATA_READ_HANDLER },
  uri: {
    UriResource: {
      ResourceKind: { BOUND_FUNCTION, COUNT, FUNCTION_IMPORT, NAVIGATION_TO_ONE, VALUE, SINGLETON }
    }
  }
} = require('@sap/odata-server')

const DelayedEmitter = require('../../utils/DelayedEmitter')
const getError = require('../../../util/getError')

const OdataContext = require('../utils/OdataContext')
const ODataRequest = process.env.CDS_FEATURES_NONG ? require('../ODataRequest') : Object

const setSapMessageHeader = require('../utils/sap-message-header')
const { isCustomOperation, skipToken } = require('../utils/request')
const { toODataResult } = require('../utils/event')
const { validateResourcePath } = require('../utils/request')
const { isStreaming, getContentType } = require('../utils/stream')
const { isSingleton } = require('../utils/handlerUtils')

/**
 * Checks whether a bound function or function import is invoked.
 * @param {Array} segments - The uri path segments of the request.
 * @returns {boolean} - True if a function is invoked, else false.
 * @private
 */
const _isFunction = segments => [BOUND_FUNCTION, FUNCTION_IMPORT].includes(segments[segments.length - 1].getKind())

/**
 * Check which type needs to be returned. If the result is not of this type, convert.
 * @param {Object} lastSegment
 * @param {*} result
 * @returns {string|Object}
 * @private
 */
const _convertResult = (lastSegment, result) => {
  if (!Array.isArray(result) && lastSegment.isCollection()) {
    return toODataResult([result])
  }

  if (Array.isArray(result) && !lastSegment.isCollection()) {
    return toODataResult(result[0])
  }

  return toODataResult(result)
}

/**
 * Invoke a function.
 * @param {Object} service
 * @param {Object} context
 * @param {Array} segments
 * @return {Promise}
 * @private
 */
const _invokeFunction = (service, context, segments) => {
  const lastSegment = segments[segments.length - 1]
  return service.processEvent(context).then(result => {
    return _convertResult(lastSegment, result)
  })
}

/**
 * Checks whether a count of entities is requested
 * (not count embedded into collection).
 * @param {Array} segments - The uri path segments of the request.
 * @returns {boolean} - True if a count of entities is requested, else false.
 * @private
 */
const _isCount = segments => {
  return segments[segments.length - 1].getKind() === COUNT
}

const _getContext = (readContext, shareContext) => {
  if (shareContext) {
    const countContext = Object.assign(Object.create(DelayedEmitter.prototype), readContext)

    const atomicityGroupId = countContext._.odataReq.getAtomicityGroupId()
    if (atomicityGroupId) {
      countContext.setStore(countContext._.shared.eventEmitterOfAtomicityGroup.get(atomicityGroupId))
    }

    return countContext
  }

  return readContext
}

/**
 * Get the count by using the general READ CQN and alter it to a COUNT query.
 * @param {Object} service
 * @param {Object} readContext
 * @param {boolean} shareContext
 * @return {Promise}
 * @private
 */
const _getCount = (service, readContext, shareContext = false) => {
  // REVISIT: this process appears to be rather clumsy

  // Copy CQN including from and where and changing columns
  const select = readContext.statements.SELECT.from(readContext.query.SELECT.from, [{ 'COUNT(1)': 'counted' }])

  if (readContext.query.SELECT.where) {
    select.SELECT.where = readContext.query.SELECT.where
  }

  const context = _getContext(readContext, shareContext)

  // preserve _target
  select._target = context.query._target

  // remove as Object.defineProperty would cause a conflict
  delete context.query

  // Define new CQN
  context.query = select

  return (
    service
      .processEvent(context)
      // Transform into scalar result
      .then(result => {
        return result[0] && result[0].counted ? result[0].counted : 0
      })
  )
}

/**
 * Checks whether a collection of entities or a single entity is requested.
 * Returns false in case of a custom operation.
 * @returns {boolean} - True if a collection of entities is requested, else false.
 * @private
 */
const _isCollection = segments => {
  const lastEntitySegment = Array.from(segments)
    .reverse()
    .find(segment => segment.getProperty() === null)
  const kind = lastEntitySegment.getKind()

  return (
    !isCustomOperation(segments) &&
    kind !== NAVIGATION_TO_ONE &&
    kind !== COUNT &&
    kind !== VALUE &&
    kind !== SINGLETON &&
    lastEntitySegment.getKeyPredicates().length === 0
  )
}

/**
 * Checks whether the count needs to be included in the result set as an annotation.
 * @param {Object} req - The odata-v4 request.
 * @returns {boolean}
 * @private
 */
const _checkIfCountToBeIncluded = req => {
  return req.getUriInfo().getQueryOption(QueryOptions.COUNT)
}

/**
 * Checks whether single entity via navigation-to-one is requested.
 * @returns {boolean}
 * @private
 */
const _isNavigationToOne = segments => {
  return segments[segments.length - 1].getKind() === NAVIGATION_TO_ONE
}

const _hasRedirectProperty = elements => {
  return Object.values(elements).some(val => {
    return val['@Core.IsURL']
  })
}

const _addMediaType = (key, entry, mediaType) => {
  if (mediaType) {
    if (typeof mediaType === 'object') {
      entry[`${key}@odata.mediaContentType`] = entry[Object.values(mediaType)[0]]
    } else {
      entry[`${key}@odata.mediaContentType`] = mediaType
    }
  }
}

const _transformRedirectProperties = (context, result) => {
  if (!Array.isArray(result) || result.length === 0) {
    return
  }

  // optimization
  if (!_hasRedirectProperty(context.target.elements)) {
    return
  }

  for (const entry of result) {
    for (const key of Object.keys(entry)) {
      if (entry[key] !== undefined && context.target.elements[key]['@Core.IsURL']) {
        entry[`${key}@odata.mediaReadLink`] = entry[key]
        _addMediaType(key, entry, context.target.elements[key]['@Core.MediaType'])
        delete entry[key]
      }
    }
  }
}

/**
 * Reading the full entity or only a property of it is alike.
 * In case of an entity, odata-v4 wants the value an object structure,
 * in case of a property as scalar.
 * @param {Object} service
 * @param {Object} context
 * @param {Array} segments
 * @return {Promise}
 * @private
 */
const _readEntityOrProperty = (service, context, segments) => {
  return service.processEvent(context).then(result => {
    if (result.length === 0 && _isNavigationToOne(segments)) {
      return toODataResult(null)
    }

    // Reading one entity or a property of it should yield only a result length of one.
    if (result.length !== 1) {
      throw getError(404)
    }

    const index = segments[segments.length - 1].getKind() === VALUE ? 2 : 1
    const propertyElement = segments[segments.length - index].getProperty()

    if (propertyElement === null) {
      _transformRedirectProperties(context, result)

      return toODataResult(result[0])
    }

    const modifiedResult = toODataResult(result[0][propertyElement.getName()])

    // property is read via a to one association and last segment is not $value
    if (index !== 2 && segments.length > 2) {
      // remove property from result (contains only keys now)
      delete result[0][propertyElement.getName()]
      // prepare key map for Okra
      modifiedResult.keysForParam = new Map().set(segments[segments.length - index - 1], result[0])
    }

    return modifiedResult
  })
}

/**
 * Read an entity collection without including the count of the total amount of entities.
 * @param {Object} service
 * @param {Object} context
 * @param {Object} req
 * @return {Promise}
 * @private
 */
const _readCollectionNoCount = (service, context, req) => {
  return service.processEvent(context).then(result => {
    const modifiedResult = toODataResult(result)

    const limit =
      context.query &&
      context.query.SELECT.limit &&
      context.query.SELECT.limit.rows &&
      context.query.SELECT.limit.rows.val
    if (limit && limit === result.length && limit !== req.getUriInfo().getQueryOption(QueryOptions.TOP)) {
      modifiedResult['*@odata.nextLink'] = skipToken(req.getUriInfo()) + limit
    }

    _transformRedirectProperties(context, result)

    return modifiedResult
  })
}

/**
 * Read an entity collection and include the count count of the total amount of entities.
 * odata-v4 wants the count to be added as annotation.
 * @param {Object} service
 * @param {Object} context
 * @param {Object} req
 * @return {Promise}
 * @private
 */
const _readCollectionWithCount = (service, context, req) => {
  context.query.SELECT.count = true

  return _readCollectionNoCount(service, context, req).then(result => {
    result['*@odata.count'] = result.value.$count
    return result
  })
}

/**
 * Reading the full entity or only a property of it is alike.
 * In case of an entity, odata-v4 wants the value an object structure,
 * in case of a property as scalar.
 * @param {Object} service
 * @param {Object} context
 * @param {Array} segments
 * @return {Promise}
 * @private
 */
const _readStream = (service, context, segments) => {
  context._.streaming = true
  return service.processEvent(context).then(result => {
    // Reading one entity or a property of it should yield only a result length of one.
    if (result.length === 0) {
      throw getError(404)
    }

    const streamObj = result[0]
    const stream = streamObj.value

    if (stream) {
      stream.on('error', () => {
        stream.removeAllListeners('error')
        // stream.destroy() does not end stream in node 10 and 12
        stream.push(null)
      })
    }

    return getContentType(segments, service.name, service.model.definitions, context).then(contentType => {
      if (contentType) {
        streamObj['*@odata.mediaContentType'] = contentType
      }

      return streamObj
    })
  })
}

/**
 * Depending on the read request segments, create one ore more reading service request.
 * @param {Object} service
 * @param {Object} context
 * @param {Object} req
 * @return {Promise}
 * @private
 */
const _readAndTransform = (service, context, req) => {
  const segments = req.getUriInfo().getPathSegments()

  if (_isFunction(segments)) {
    return _invokeFunction(service, context, segments)
  }

  // Scalar count is requested
  if (_isCount(segments)) {
    return _getCount(service, context).then(result => {
      return toODataResult(result)
    })
  }

  if (_isCollection(segments)) {
    if (_checkIfCountToBeIncluded(req)) {
      return _readCollectionWithCount(service, context, req)
    }

    return _readCollectionNoCount(service, context, req)
  }

  if (isStreaming(segments)) {
    return _readStream(service, context, segments)
  }

  if (isSingleton(context.target)) {
    return service.processEvent(context).then(result => {
      if (result.length === 0 && _isNavigationToOne(segments)) {
        return toODataResult(null)
      }
      if (result.length === 0) throw getError(404)
      return toODataResult(result[0])
    })
  }

  return _readEntityOrProperty(service, context, segments)
}

/**
 * The handler that will be registered with odata-v4.
 *
 * If an entity collection is read, it calls next with result as an Array with all entities of the collection.
 * If a count of the entities in the collection is requested, it uses number of the entities as a Number value.
 * If an single entity is read, it uses the entity as an object.
 * If a property of a single entity is requested (e.g. /Books(1)/name), it unwraps the property from the result.
 * If the single entity to be read does not exist, calls next with error to return a 404.
 * In all other failure cases it calls next with error to return a 500.
 *
 * @param {Service} service
 * @param {Object} options
 * @return {Function}
 */
const read = (service, options) => {
  return (req, res, next) => {
    // const incomingReq = req.getIncomingRequest()
    // if (incomingReq && incomingReq.performanceMeasurement) {
    //   incomingReq.performanceMeasurement.performance.mark(`${incomingReq.performanceMeasurement.uuid} ODataIn End`)
    //   incomingReq.performanceMeasurement.performance.measure(
    //     `${incomingReq.performanceMeasurement.uuid} 1 ODataIn`,
    //     `${incomingReq.performanceMeasurement.uuid} ODataIn Start`,
    //     `${incomingReq.performanceMeasurement.uuid} ODataIn End`
    //   )
    // }

    // End here if length is greater then allowed
    validateResourcePath(req, options, service.model)

    let context
    if (process.env.CDS_FEATURES_NONG) {
      context = new ODataRequest(DATA_READ_HANDLER, service, req, res)
    } else {
      context = new OdataContext(DATA_READ_HANDLER, service, req, res, true)
    }

    // Get the service result(s) and hand them over the odata-v4
    _readAndTransform(service, context, req)
      .then(result => {
        if (req.getConcurrentResource() !== null) {
          const element = Object.values(context.target.elements).find(element => {
            return element['@odata.etag']
          })
          if (Array.isArray(result.value)) {
            result.value.forEach(val => {
              val['*@odata.etag'] = val[element.name]
            })
          } else {
            result.value['*@odata.etag'] = result.value[element.name]
          }
        }

        let options

        if (result.keysForParam) {
          options = { keys: result.keysForParam }
          delete result.keysForParam
        }

        setSapMessageHeader(res, context._.infos)
        context.emit('succeeded')
        context.emit('done')
        next(null, result, options)
      })
      .catch(err => {
        setSapMessageHeader(res, context._.infos)
        context.emit('failed', err)
        context.emit('done')
        next(err)
      })
  }
}

module.exports = read
