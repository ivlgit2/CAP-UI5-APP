const {
  messages: { DB_CONNECTION_MISSING }
} = require('../utils/constants')
const getColumns = require('../utils/columns')
const { getSelectCQN, allKeysAreProvided, checkNotNull, rejectSkippedEntity } = require('../utils/handlerUtils')
const { isSingleton } = require('../../adapter/odata-v4/utils/handlerUtils')
const { resolveCqnIfView, getTargetData } = require('../utils/defaultHandlers')

const _enrichKeysFromOldData = (context, oldData) => {
  const data = context.data && (Array.isArray(context.data) ? context.data : [context.data])
  for (const key of Object.values(context.target.keys)) {
    for (const d of data) {
      // If key not in data, check if in old data (example case: PATCH singleton)
      if (d[key.name] === undefined && oldData && oldData[key.name] !== undefined) {
        d[key.name] = oldData[key.name]
      }
    }
  }
}

const _getInsertCQN = context => {
  const { target, data } = getTargetData(context.target, Object.assign({}, context.data))

  return context.statements.INSERT.into(target).entries([data])
}

const _containsChanges = async context => {
  const diffKeys = Object.keys(await context.diff())
  const entityKeys = Object.keys(context.target.keys)
  return diffKeys.length !== entityKeys.length
}

/*
 * read data as on db and return
 */
const _getResult = async context => {
  const cols = Object.keys(context.target.elements).filter(
    k => context.target.elements[k].type !== 'cds.Association' && context.target.elements[k].type !== 'cds.Composition'
  )

  const cqn = getSelectCQN(context, cols)
  const data = await context.run(cqn)

  return Array.isArray(data) && data.length > 0 ? data[0] : {}
}

const _getCurrent = async (context, _allKeysAreProvided) => {
  const neededColumns = getColumns(context.target, true)

  let current = context && context._ && context._.partialPersistentState
  if (!current) {
    current = _allKeysAreProvided ? await context.run(getSelectCQN(context, neededColumns)) : []
  }

  return current
}

const _getUpdateCQN = context => {
  const cqn = resolveCqnIfView(context)

  // add where from select, if missing
  if (!cqn.UPDATE.where && context.target && isSingleton(context.target)) {
    const select = getSelectCQN(context)
    cqn.UPDATE.where = select && select.SELECT && select.SELECT.where
  }

  if (!cqn.UPDATE.where) {
    context.reject(400, 'Ambiguous entity instance')
    return
  }

  return cqn
}

/**
 * Generic Handler for UPDATE requests.
 * In case of success it returns the updated entry.
 * If the entry to be updated does not exist, a new entry is created.
 *
 * @param context - operation object, that provides error, continuation and other functions as well as information
 * regarding the current operation.
 * @alias module:handlers.onUpdate
 */
const onUpdate = () => async context => {
  if (!context.run) {
    context.log.warn(DB_CONNECTION_MISSING)
    return context.data
  }

  if (context.target['@cds.persistence.skip'] === true) {
    rejectSkippedEntity(context)
    return
  }

  const _allKeysAreProvided = allKeysAreProvided(context)

  /*
   * UPDATE or UPSERT
   *
   * if no key information given, or entry is not available -> create a new one
   * else if changes -> update
   * else -> do nothing
   */

  const current = await _getCurrent(context, _allKeysAreProvided)
  if (current.length === 0) {
    // reject with error if upsert not allowed
    if (global.cds.env.runtime && global.cds.env.runtime.allow_upsert === false) {
      context.reject(404)
      return
    }

    if (checkNotNull(context)) {
      return
    }

    await context.run(_getInsertCQN(context))
  } else if (await _containsChanges(context)) {
    // Store for auditing
    context._oldData = current[0]
    if (!_allKeysAreProvided && isSingleton(context.target)) _enrichKeysFromOldData(context, current[0])
    const cqn = _getUpdateCQN(context)
    if (!cqn) {
      // request already rejected
      return
    }

    await context.run(cqn)
  }

  return _getResult(context)
}

module.exports = onUpdate
