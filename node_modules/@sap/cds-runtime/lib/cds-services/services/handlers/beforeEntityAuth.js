/* eslint-disable no-new-wrappers */

const { getIpFromRequest } = require('../utils/clientFromRequest')
const defaultEvents = ['CREATE', 'READ', 'UPDATE', 'DELETE', 'NEW', 'PATCH', 'EDIT', 'CANCEL']

const _getErrorMessage = event => `${event} is only allowed with static instance-based authorization`

const _evaluate = (ref, context) => {
  return ref.reduce((prev, curr) => {
    return prev ? prev[curr.replace(/^\$/, '')] : prev
  }, context)
}

const symbol = Symbol.for('sap.cds.FROM_ANNOTATION')

const _addSymbol = element => {
  if (typeof element === 'string') {
    const str = new String(element)
    str[symbol] = true
    return str
  }

  element[symbol] = true
  return element
}

const _equals = (str1, str2) => {
  const s1 = typeof str1 === 'string' ? str1 : str1.toString()
  const s2 = typeof str2 === 'string' ? str2 : str2.toString()

  return s1 === s2
}

const _isString = s => typeof s === 'string' || s instanceof String

const _valuesToOrConditions = (refOrVal, op, values) => {
  const arr = ['(']

  for (const value of values) {
    if (arr.length !== 1) {
      arr.push('or')
    }

    // copy because of multiple usage
    const refOrValCopy = refOrVal.ref ? { ref: [...refOrVal.ref], as: refOrVal.as } : { val: refOrVal.val }
    arr.push(_addSymbol(refOrValCopy), op, _addSymbol({ val: value }))
  }

  arr.push(')')

  return arr
}

const _xprToCondition = (context, refOrVal, op, userRef) => {
  let attrValue = userRef.ref.length === 1 ? context.user.id : _evaluate(userRef.ref, context)

  if (attrValue === undefined) {
    // HANA does not support TRUE as expression
    return [_addSymbol({ val: '1' }), _addSymbol('='), _addSymbol({ val: '1' })]
  }

  if (Array.isArray(attrValue)) {
    return _valuesToOrConditions(refOrVal, op, attrValue)
  }

  return [refOrVal, op, _addSymbol({ val: attrValue })]
}

const _handleSubselect = (element, context) => {
  if (typeof element === 'object' && element.SELECT && element.SELECT.where) {
    element.SELECT.where = _parseWhereFromXpr(context, element.SELECT.where)
  }
}

const _parseWhereFromXpr = (context, xpr) => {
  const length = xpr ? xpr.length : 0

  const processed = []
  let i = 0

  while (i < length) {
    _handleSubselect(xpr[i], context)

    if (i < length - 2 && (xpr[i].ref || xpr[i].val) && _isString(xpr[i + 1]) && (xpr[i + 2].ref || xpr[i + 2].val)) {
      if (xpr[i].ref && xpr[i].ref[0] === '$user') {
        processed.push(..._xprToCondition(context, xpr[i + 2], xpr[i + 1], xpr[i]))
      } else if (xpr[i + 2].ref && xpr[i + 2].ref[0] === '$user') {
        processed.push(..._xprToCondition(context, xpr[i], xpr[i + 1], xpr[i + 2]))
      } else {
        processed.push(xpr[i], xpr[i + 1], xpr[i + 2])
      }
      i += 3
    } else {
      processed.push(xpr[i])
      i++
    }
  }

  return processed
}

/**
 * Replace $user with context.user.id
 * and $user.bla.bla with context.user.bla.bla.
 * Afterwards split to parts by space.
 *
 * @param annotatedWhere
 * @param context
 *
 * @private
 */
const _parseWhere = (annotatedWhere, context) => {
  let { xpr } = global.cds.parse.expr(annotatedWhere)
  xpr = xpr.map(element => _addSymbol(element))

  return _parseWhereFromXpr(context, xpr)
}

const _cqnToData = on => {
  const data = {}
  const length = on.length
  let i = 0

  while (i < length) {
    if (on[i].ref && _equals(on[i + 1], '=') && on[i + 2].val) {
      data[on[i].ref[on[i].ref.length - 1]] = on[i + 2].val
      i += 3
    } else {
      i++
    }
  }

  return data
}

const _changeUpdate = (wheres, context) => {
  const parsed = _cqnToData(_parseWhere(wheres[0], context))

  if (context.data) {
    Object.assign(context.data, parsed)
  }

  Object.assign(context.query.UPDATE.data, parsed)
}

const _getValueFromContext = (reference, context) => {
  // the reference arg in WHERE is $user
  if (reference.length === 1) {
    return context.user.id
  }

  let staticValue = context.user
  // the reference arg in WHERE is $user property
  for (var i = 1; i < reference.length; i++) {
    if (staticValue === undefined) {
      return
    }
    staticValue = staticValue[reference[i]]
  }

  return staticValue
}

const _isValueIncludedOrEqual = (value1, value2) => {
  if (Array.isArray(value1)) {
    return value1.includes(value2)
  } else if (Array.isArray(value2)) {
    return value2.includes(value1)
  } else {
    return value1 === value2
  }
}

const _checkValue = (first, operator, second, context, event) => {
  let value1
  let value2
  if (first && first.ref && first.ref[0] === '$user' && second && second.val) {
    value1 = _getValueFromContext(first.ref, context)
    value2 = second.val
  }
  if (second && second.ref && second.ref[0] === '$user' && first && first.val) {
    value1 = first.val
    value2 = _getValueFromContext(second.ref, context)
  }
  if (value1 === undefined && value2 === undefined) {
    return context.reject(403, _getErrorMessage(event))
  }
  if (value1 === undefined || value2 === undefined) {
    return context.reject(403)
  }
  let isAllowed = false

  switch (operator) {
    case '=':
      isAllowed = _isValueIncludedOrEqual(value1, value2)
      break
    case '>':
      isAllowed = value1 > value2
      break
    case '<':
      isAllowed = value1 < value2
      break
    case '!=':
      isAllowed = value1 !== value2
      break
    case '<=':
      isAllowed = value1 <= value2
      break
    case '>=':
      isAllowed = value1 >= value2
      break
    default:
      return context.reject(400, `${operator} in instance-based authorization is not supported`)
  }

  if (!isAllowed) {
    return context.reject(403)
  }
}

const _validateStaticInstanceBased = (wheres, context, event) => {
  const { xpr } = global.cds.parse.expr(wheres[0]['='] || wheres[0])
  if (xpr.length > 3) {
    return context.reject(403, _getErrorMessage(event))
  }
  return _checkValue(xpr[0], xpr[1], xpr[2], context, event)
}

const _authStatus = (annotations, context) => {
  const auth = {
    status: 'not granted',
    where: []
  }

  for (const anno of annotations) {
    if (anno.to) {
      if (context.user.has(anno.to)) {
        if (!anno.where) {
          auth.status = 'granted'
          return auth
        }
        auth.status = 'where'
        auth.where.push(anno.where)
      }
    } else {
      auth.status = 'where'
      auth.where.push(anno.where)
    }
  }

  return auth
}

const _hasExpand = columns => {
  for (const col of columns) {
    if (col.expand) {
      return true
    }
  }

  return false
}

const _getTableForColumn = (col, aliases, model) => {
  for (let i = 0; i < aliases.length; i++) {
    const alias = aliases[i]
    if (Object.keys(model.definitions[alias].elements).includes(col)) {
      return { index: i, table: alias.replace(/\./g, '_') }
    }
  }

  return { index: -1 }
}

const _findTableName = (ref, aliases) => {
  const maxLength = Math.max(...aliases.map(alias => alias.length))
  let name = ''
  for (let i = 0; i < ref.length; i++) {
    name += name.length !== 0 ? `.${ref[i]}` : ref[i]

    if (name >= maxLength) {
      break
    }

    const aliasIndex = aliases.indexOf(name)
    if (aliasIndex !== -1) {
      return { refIndex: i, aliasIndex: aliasIndex, name: name }
    }
  }

  return { refIndex: -1 }
}

const _adaptTableName = (ref, index, name) => {
  let tableName = name.replace(/\./g, '_')
  ref.splice(0, index + 1, tableName)
}

const _ensureTableAlias = (ref, aliases, targetFrom, model, hasExpand) => {
  const nameObj = _findTableName(ref, aliases)
  if (nameObj.refIndex === -1) {
    const { index, table } = _getTableForColumn(ref[0], aliases, model)
    if (index !== -1) {
      nameObj.aliasIndex = index
      if (table === targetFrom.name && targetFrom.as) {
        ref.unshift(targetFrom.as)
      } else {
        ref.unshift(table)
      }
    }
  } else {
    _adaptTableName(ref, nameObj.refIndex, nameObj.name)
  }

  if (hasExpand && nameObj.aliasIndex === 0) {
    _addSymbol(ref)
  }
}

const _enhanceAnnotationSubSelect = (select, model, targetName, targetFrom, hasExpand) => {
  if (select.from && select.from.ref) {
    _addSymbol(select.from.ref)
  }
  if (select.where) {
    for (const v of select.where) {
      if (v.ref && select.from.ref) {
        _ensureTableAlias(v.ref, [targetName, select.from.ref[0]], targetFrom, model, hasExpand)
      }
    }
  }
}

// Add alias symbols to refs if needed and mark ref (for expand) and SELECT.from (for draft)
const _enhanceAnnotationWhere = (query, where, model) => {
  const hasExpand = query.SELECT && _hasExpand(query.SELECT.columns || [])
  const targetFrom = query.SELECT
    ? {
      name: query.SELECT.from.ref[0].replace(/\./g, '_'),
      as: query.SELECT.from.as
    }
    : {}
  for (const w of where) {
    if (w.ref) {
      _ensureTableAlias(w.ref, [query._target.name], targetFrom, model, hasExpand)
    } else if (w.SELECT) {
      _enhanceAnnotationSubSelect(w.SELECT, model, query._target.name, targetFrom, hasExpand)
    }
  }
}

const _checkAnnotationWhereUpdateDelete = async (context, whereClause) => {
  const table = context.target.name
  const where = context.query.UPDATE ? context.query.UPDATE.where : context.query.DELETE.where
  const select = context.statements.SELECT.from(table).where(where)
  const selectWhere = context.statements.SELECT.from(table)
    .where(where)
    .where(['(', ...whereClause, ')'])
  const result = await context.run(select)
  const resultWhere = await context.run(selectWhere)

  if (result.length !== resultWhere.length) {
    context.reject(404)
  }
}

/**
 * Get generic authorization handler for CRUD requests on entity level.
 * The handler to be registered as a before handler.
 *
 * @param annotations - prepared authorization (restrict or requires) annotations
 * @param auditLogger - the audit logger object
 */
const getAuthEntityHandler = (annotations, auditLogger, model) => {
  /**
   * @param context - operation object, that provides error, continuation and other functions as well as information
   * regarding the current operation.
   */
  return async context => {
    const { status, where } = _authStatus(annotations, context)

    if (status === 'granted') return

    // TODO: wait for answer: || (context.query.INSERT && status === 'where')
    if (status === 'not granted') {
      auditLogger.logMissingPermissions({
        user: context.user.id,
        ip: getIpFromRequest(context._.req),
        tenant: context.attr.identityZone
      })

      return context.reject(403)
    }

    if (context.query.INSERT) {
      return _validateStaticInstanceBased(where, context, 'CREATE')
    }

    if (!defaultEvents.includes(context.event)) {
      return _validateStaticInstanceBased(where, context, 'Custom operation')
    }

    if (context.query.UPDATE) {
      _changeUpdate(where, context)
    }

    const whereClause = where.reduce((clause, condition, index) => {
      if (index !== 0) {
        clause.push('OR')
      }
      clause.push(..._parseWhere(condition, context))
      return clause
    }, [])

    if (context.query.SELECT) {
      _enhanceAnnotationWhere(context.query, whereClause, model)
      context.query.where(['(', ...whereClause, ')'])
    } else if (context.query.UPDATE || context.query.DELETE) {
      await _checkAnnotationWhereUpdateDelete(context, whereClause)
    }
  }
}

module.exports = getAuthEntityHandler
