const {
  messages: { DB_CONNECTION_MISSING }
} = require('../utils/constants')
const {
  getDeepSelect,
  getSelectCQN,
  allKeysAreProvided,
  checkNotNull,
  rejectSkippedEntity
} = require('../utils/handlerUtils')
const { resolveCqnIfView } = require('../utils/defaultHandlers')

const _isBatch = context => {
  return Array.isArray(context.data)
}

/*
 * optimistically transforms result from flat to complex based on input
 */
const _transformToComplex = (data, context) => {
  const isBatch = _isBatch(context)

  for (let i = 0; i < data.length; i++) {
    const d = data[i]
    const cd = isBatch ? context.data[i] : context.data

    const props = Object.keys(d)
    const keys = Object.keys(cd).filter(k => !props.includes(k))

    for (const k of keys) {
      const inner = props.filter(p => p.startsWith(`${k}_`)).map(p => p.split(`${k}_`)[1])
      if (inner.length > 0) {
        d[k] = {}
        for (const i of inner) {
          d[k][i] = d[`${k}_${i}`]
          delete d[`${k}_${i}`]
        }
      }
    }
  }

  return isBatch ? data : data[0]
}

/*
 * read data as on db and return
 */
const _getResult = async context => {
  const cqn = getDeepSelect(context, context[Symbol.for('sap.cds.model')].definitions)
  const data = await context.run(cqn)

  if (!Array.isArray(data) || data.length === 0) {
    return _isBatch(context) ? [] : {}
  }

  return context.constructor.name === 'RestContext' ? _transformToComplex(data, context) : data[0]
}

/**
 * Generic Handler for CREATE requests.
 * In case of success it returns the created entry.
 *
 * @param context - operation object, that provides error, continuation and other functions as well as information
 * regarding the current operation.
 * @alias module:handlers.onCreate
 */
const onCreate = () => async context => {
  if (!context.run) {
    context.log.warn(DB_CONNECTION_MISSING)

    return context.data
  }

  if (context.target['@cds.persistence.skip'] === true) {
    rejectSkippedEntity(context)
    return
  }

  const _allKeysAreProvided = allKeysAreProvided(context)
  const keys = Object.values(context.target.keys)
    .filter(key => !(key.is2one || key.is2many))
    .map(key => key.name)

  const result = _allKeysAreProvided ? await context.run(getSelectCQN(context, keys)) : []

  // If entry is available, reject event
  if (result && result.length > 0) {
    context.reject(400, 'Entity Already Exists')
    return
  }

  if (checkNotNull(context)) {
    return
  }

  await context.run(resolveCqnIfView(context))

  // If we cannot perform the SELECTs (e.g. because of missing keys) we can't return
  // the full entity (with keys), just context.data
  // Custom after handlers then must provide the correct response.
  return _allKeysAreProvided ? _getResult(context) : context.data
}

module.exports = onCreate
