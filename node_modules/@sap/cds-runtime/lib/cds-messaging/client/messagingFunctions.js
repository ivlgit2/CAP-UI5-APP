const dataHandler = require('./dataHandler')
const https = require('https')
const { resolve } = require('../utils/thenable')
const crypto = require('crypto')

const INVALID_SYMBOLS = /\W|_/g

function _on (options) {
  const _onHandler = function (event, handler) {
    if (Array.isArray(event)) {
      for (const _event of event) {
        _onHandler.call(this, _event, handler)
      }
    } else {
      const prefixForUnmanagedTopic = _getPrefixForUnmanagedTopic(options)
      const normalized = _normalizeOnArgs(event, handler, prefixForUnmanagedTopic)

      _onNormalized.call(this, normalized, options)
    }
    return this
  }
  return _onHandler
}

function _deriveSource ({ shrunkService, appName, appID, ownNamespace }) {
  const shrunkAppID = appID.substring(0, 4)
  return ownNamespace
    ? `queue:${ownNamespace}/${appName}/${shrunkAppID}/${shrunkService}`
    : `queue:${appName}/${shrunkAppID}/${shrunkService}`
}

function _shrinkService (service) {
  const separatedServiceName = service.split('.')
  const serviceWithoutNamespace = separatedServiceName.pop().replace(INVALID_SYMBOLS, '')
  const namespaceHash = crypto
    .createHash('md5')
    .update(separatedServiceName.join('.') || '')
    .digest('hex')
    .substring(0, 4)
  return `${serviceWithoutNamespace}/${namespaceHash}`
}

function _pendingOperations (that) {
  that._pendingOperations = that._pendingOperations || resolve()
  return that._pendingOperations
}

function bind (service, model) {
  const msgOptions = this.options.connectionOptions.get('messaging')
  const namespaceOfService =
    process.env.MESSAGING_NAMESPACE || (msgOptions.credentials && msgOptions.credentials.namespace)
  const vcapApplication = process.env.VCAP_APPLICATION && JSON.parse(process.env.VCAP_APPLICATION)
  const appName = (vcapApplication && vcapApplication.application_name.replace(INVALID_SYMBOLS, '')) || 'unknownApp'
  const appID = (vcapApplication && vcapApplication.application_id) || '0000'
  const shrunkService = _shrinkService(service)
  const prefix = msgOptions.credentials && msgOptions.credentials.prefix
  const queueConfig = msgOptions.credentials && msgOptions.credentials.queueConfig
  const customSource = msgOptions.credentials && msgOptions.credentials.queue && `queue:${msgOptions.credentials.queue}`

  const options = {
    queueConfig,
    appID,
    appName,
    service,
    model,
    shrunkService,
    customSource,
    namespaceOfService,
    prefix,
    onHandlers: [],
    errHandlers: []
  }

  const boundMessagingFunctions = {
    messagingOptions: options,
    emit: _emit(options).bind(this),
    on: _on(options).bind(this)
  }

  boundMessagingFunctions.on.error = _onError(options).bind(this)

  return boundMessagingFunctions
}

bind.service = bind.bind(this)

function _getPrefixForManagedTopic (options, client) {
  return options.prefix || `${options.namespaceOfService || client._options.namespace}/${options.shrunkService}`
}

function _getPrefixForUnmanagedTopic (options) {
  return options.prefix
}

async function _addSubscriptionForHandler (onHandler, options) {
  await _pendingOperations(this)
  const client = await this.acquire({}, 'messaging')

  const source = _getSource(client, options)
  const queueName = _getQueueNameFromSource(source)
  const prefixForManagedTopic = _getPrefixForManagedTopic(options, client)
  const topic = _getTopicFromOnHandler(onHandler, prefixForManagedTopic)
  const management = client._options.management
  if (client._options.kind === 'enterprise-messaging') {
    await _pendingOperations(client)
    await this.addSubscription(queueName, topic, management)
    client._pendingOperations = null
  } else {
    client._clientEM.addSubscription(topic)
  }
  await this.release(client)
  this._pendingOperations = null
}

function _getSource (client, options) {
  const ownNamespace = client._options.namespace
  return (
    options.customSource ||
    _deriveSource({
      shrunkService: options.shrunkService,
      appName: options.appName,
      appID: options.appID,
      ownNamespace
    })
  )
}

function _createQueueAndAddSubscription (normalizedHandler, options) {
  return this.acquire({}, 'messaging').then(client => {
    const source = _getSource(client, options)
    const queueName = _getQueueNameFromSource(source)
    const prefixForManagedTopic = _getPrefixForManagedTopic(options, client)
    const management = client._options.management
    const topic = _getTopicFromOnHandler(normalizedHandler, prefixForManagedTopic)
    if (client._options.kind === 'enterprise-messaging') {
      client._pendingOperations = _pendingOperations(client)
        .then(() => {
          return this.putQueue(queueName, options, management)
        })
        .then(() => {
          return this.addSubscription(queueName, topic, management)
        })
        .then(() => {
          client._pendingOperations = null
        })
    } else {
      client._clientEM.addSubscription(topic)
    }
    client.on(dataHandler(options.onHandlers, options.errHandlers, prefixForManagedTopic), null, source)
    this.release(client)
  })
}

function _onNormalized (normalizedHandler, options) {
  if (normalizedHandler.handler) {
    _checkValidEvent(normalizedHandler, options)
    options.onHandlers.push(normalizedHandler)
  }

  // Registration once a handler is registered
  _pendingOperations(this).then(() => {
    if (options.onHandlers && options.onHandlers.length === 1) {
      _createQueueAndAddSubscription.call(this, normalizedHandler, options)
    } else {
      _addSubscriptionForHandler.call(this, normalizedHandler, options)
    }
  })
}

function _checkValidEvent (normalizedHandler, options) {
  if (normalizedHandler.event && options.model && options.service) {
    const childrenOfService = options.model.childrenOf(options.service)
    const csnEvent = childrenOfService && childrenOfService[normalizedHandler.event]
    if (!csnEvent || csnEvent.kind !== 'event') {
      throw new Error(`Element '${normalizedHandler.event}' is not in model.`)
    }
  }
}

function _getQueueNameFromSource (source) {
  return source.replace('queue:', '')
}

function _getTopicFromOnHandler (onHandler, prefixForManagedTopic) {
  return onHandler.topic ? onHandler.topic : `${prefixForManagedTopic}/${onHandler.event}`
}

function _normalizeOnArgs (event, handler, prefixForUnmanagedTopic) {
  if (handler && handler._handlerName) {
    const splitted = handler._handlerName.split('.')
    handler = splitted[splitted.length - 1]
  }
  let [_event, _handler, _topic] = handler
    ? event.startsWith('topic:') || event.includes('/')
      ? prefixForUnmanagedTopic
        ? [undefined, handler, event.replace(/^topic:/, '').replace(/^/, `${prefixForUnmanagedTopic}/`)]
        : [undefined, handler, event.replace(/^topic:/, '')]
      : [event, handler, undefined]
    : ['*', event, undefined]

  return { event: _event, handler: _handler, topic: _topic }
}

function _onError (options) {
  return function (handler) {
    ;(options.errHandlers || (options.this.errHandlers = [])).push(handler)
  }
}

async function removeAllListeners () {
  if (this.messagingOptions) {
    this.messagingOptions.onHandlers.length = 0
    this.messagingOptions.errHandlers.length = 0
  }
  try {
    const client = await this.acquire({}, 'messaging')
    const management = client._options.management
    const source = _getSource(client, this.messagingOptions)
    client.disconnect()
    this.release(client)
    const queueName = _getQueueNameFromSource(source)
    await this.deleteQueue(queueName, management)
  } catch (err) {}
}

function _emit (options) {
  return function (event, payload, header) {
    if (typeof event === 'string' && !event.startsWith('topic:') && !event.includes('/')) {
      _checkValidEvent({ event }, options)
    }
    _pendingOperations(this)
      .then(() => {
        this.acquire({}, 'messaging').then(client => {
          const prefixForManagedTopic = _getPrefixForManagedTopic(options, client)
          const prefixForUnmanagedTopic = options.prefix
          const msg = { data: payload, ...header }
          const target = _targetFromEvent(event, {
            prefixForManagedTopic,
            prefixForUnmanagedTopic
          })
          client.emit(msg, target)
          this.release(client)
        })
      })
      .then(() => {
        this._pendingOperations = null
      })
    return this
  }
}

function _targetFromEvent (event, { prefixForManagedTopic, prefixForUnmanagedTopic }) {
  return event.startsWith('topic:')
    ? prefixForUnmanagedTopic
      ? event.replace(/^topic:/, `topic:${prefixForUnmanagedTopic}/`)
      : event
    : event.includes('/')
      ? prefixForUnmanagedTopic
        ? `topic:${prefixForUnmanagedTopic}/${event}`
        : `topic:${event}`
      : `topic:${prefixForManagedTopic}/${event}`
}

function _requestOAuthToken (management) {
  return new Promise((resolve, reject) => {
    let {
      oa2: { clientid, clientsecret, tokenendpoint }
    } = management

    const options = {
      host: tokenendpoint.replace('/oauth/token', '').replace('https://', ''),
      path: '/oauth/token?grant_type=client_credentials&response_type=token',
      headers: {
        Authorization: 'Basic ' + Buffer.from(clientid + ':' + clientsecret).toString('base64')
      }
    }

    https.get(options, res => {
      res.setEncoding('utf8')
      let result = ''
      res.on('data', chunk => {
        result += chunk
      })
      res.on('end', () => {
        const json = JSON.parse(result)
        if (!json.access_token) {
          reject(new Error('Authorization failed'))
        }
        resolve(json.access_token)
      })
    })
  })
}

function _addSubscription (queueName, topicPattern, management) {
  return new Promise((resolve, reject) => {
    _requestOAuthToken(management)
      .catch(err => reject(err))
      .then(token => {
        const options = {
          host: management.uri.replace('https://', ''),
          path:
            '/hub/rest/api/v1/management/messaging/queues/' +
            encodeURIComponent(queueName) +
            '/subscriptions/' +
            encodeURIComponent(topicPattern),
          headers: {
            Authorization: 'Bearer ' + token,
            'Content-Type': 'application/json',
            'Content-Length': 0
          },
          method: 'PUT'
        }
        const req = https.request(options, res => {
          res.setEncoding('utf8')
          if (res.statusCode !== 200 && res.statusCode !== 201) {
            reject(new Error(`Subscription "${topicPattern}" could not be added to queue "${queueName}".`))
          }

          res.on('data', body => {
            resolve()
          })
        })

        req.write('')
        req.end()
      })
  })
}

function addSubscription (queueName, topicPattern, management) {
  if (!management) {
    return this.acquire({}, 'messaging').then(client => {
      const management = client._options.management
      this.release(client)
      return _addSubscription(queueName, topicPattern, management)
    })
  }
  return _addSubscription(queueName, topicPattern, management)
}

function _putQueue (queueName, options, management) {
  return new Promise((resolve, reject) => {
    _requestOAuthToken(management)
      .catch(err => reject(err))
      .then(token => {
        const data = JSON.stringify((options && options.queueConfig) || { maxQueueSizeInBytes: 0 })
        const httpOptions = {
          host: management.uri.replace('https://', ''),
          path: '/hub/rest/api/v1/management/messaging/queues/' + encodeURIComponent(queueName),
          headers: {
            Authorization: 'Bearer ' + token,
            'Content-Type': 'application/json',
            'Content-Length': data.length
          },
          method: 'PUT'
        }

        const req = https.request(httpOptions, res => {
          res.setEncoding('utf8')
          if (res.statusCode !== 200 && res.statusCode !== 201) {
            reject(new Error(`Queue "${queueName}" could not be created.`))
          }

          res.on('data', body => {
            resolve()
          })
        })

        req.write(data)
        req.end()
      })
  })
}

function putQueue (queueName, options, management) {
  if (!management) {
    return this.acquire({}, 'messaging').then(client => {
      const management = client._options.management
      this.release(client)
      return _putQueue(queueName, options, management)
    })
  }
  return _putQueue(queueName, options, management)
}

function _deleteQueue (queueName, management) {
  return new Promise((resolve, reject) => {
    _requestOAuthToken(management)
      .catch(err => reject(err))
      .then(token => {
        const options = {
          host: management.uri.replace('https://', ''),
          path: '/hub/rest/api/v1/management/messaging/queues/' + encodeURIComponent(queueName),
          headers: {
            Authorization: 'Bearer ' + token,
            'Content-Type': 'application/json',
            'Content-Length': 0
          },
          method: 'DELETE'
        }

        const req = https.request(options, res => {
          res.setEncoding('utf8')
          if (res.statusCode !== 204 && res.statusCode !== 200) {
            reject(new Error('Queue could not be deleted'))
          }
          resolve()
        })
        req.write('')
        req.end()
      })
  })
}

function deleteQueue (queueName, management) {
  if (!management) {
    return this.acquire({}, 'messaging').then(client => {
      const management = client._options.management
      this.release(client)
      return _deleteQueue(queueName, management)
    })
  }
  return _deleteQueue(queueName, management)
}

module.exports = {
  bind,
  removeAllListeners,
  putQueue,
  deleteQueue,
  addSubscription
}
