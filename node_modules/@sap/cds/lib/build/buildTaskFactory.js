const fs = require('@sap/cds-foss')('fs-extra')
const path = require('path')
const _cds = require('../cds')
const { getProperty, hasJavaNature, isOldJavaStack, adaptBuildTargetSettingForJava } = require('./util')
const { FILE_EXT_CDS, BUILD_TASK_HANA, BUILD_TASK_FIORI, BUILD_TASK_JAVA, BUILD_TASK_NODE, BUILD_TASK_MTX, BUILD_TASK_USE_PREFIX } = require("./constants");

const DEBUG = process.env.DEBUG
// use "/" for cds config entries and not path.sep which is platform specific
const CDS_CONFIG_PATH_SEP = '/'

class BuildTaskFactory {
    constructor(logger, cds) {
        this._logger = logger || global.console
        this._cds = cds ? cds : _cds
    }
    get cds() {
        return this._cds
    }
    get env() {
        return this._cds.env
    }
    get logger() {
        return this._logger
    }

    // the following order for determining build tasks is used
    // 1. create from commandline input, e.g. cds build/all --for hana --src db --model srv --dest db
    // 2. read using cds.env.build.tasks
    // 3. create from cds.env.folders config data
    async getTasks(buildOptions = { root: process.cwd() }) {
        let tasks = this._getExistingTasks()

        if (tasks.length === 0) {
            tasks = await this._createTasksFromConfig(buildOptions)

            if (tasks.length > 0) {
                this.logger.log(`[cds] - No CDS custom build tasks defined for project [${buildOptions.root}].`)
                this.logger.log("[cds] - The following build tasks have been auto-created and will be executed.")
                this.logger.log("[cds] - You may want to add them to .cdsrc.json or package.json of your project and customize to your needs if required.")

                // Java projects that do not define any build related configuration use "." as the default build target folder -> compatibility to legacy build.
                // Projects that have build tasks configured also need to configure the build target folder, otherwise the default "gen" is used.
                if (tasks.find(task => task.for === BUILD_TASK_JAVA)) {
                    if (adaptBuildTargetSettingForJava(this.env, buildOptions.root)) {
                        this.logger.log("[cds] - using inplace build for java project instead of default staging build")
                    }
                }
            }
        }

        tasks = this._ensureConsistentTaskSettings(tasks)
        buildOptions.target = path.resolve(buildOptions.root, this.env.build.target)

        // log build tasks
        let tasksOutput = "{\n  \"build\": {\n    \"target\": \"" + this.env.build.target + "\",\n    \"tasks\": ["
        for (let i = 0; i < tasks.length; i++) {
            tasksOutput += "\n      " + JSON.stringify(tasks[i]) + (i + 1 < tasks.length ? "," : "")
        }
        tasksOutput += "\n    ]\n  }\n}\n"
        this.logger.log(tasksOutput)

        if (DEBUG) {
            this.logger.log("[cds] - cds.env used for build:")
            this.logger.log(JSON.stringify(this.env, null, 1))
        }

        if (buildOptions.resolve) {
            return tasks.map(task => this._resolveTask(task, buildOptions))
        }
        return tasks
    }

    _resolveTask(task, buildOptions) {
        const resolvedTask = Object.assign({}, task)

        if (!resolvedTask.use) {
            if (resolvedTask.for) {
                resolvedTask.use = BUILD_TASK_USE_PREFIX + resolvedTask.for
            } else {
                throw new Error("Invalid build task configuration data - either task.use or task.for definition required")
            }
        } else {
            if (!resolvedTask.for) {
                resolvedTask.for = resolvedTask.use.split("/").pop()
            }
        }
        if (!resolvedTask.for) {
            resolvedTask.for = resolvedTask.use.split("/").pop()
        }

        try {
            // resolving sym-links, but be careful as realpathSync is throwing exception if directory does not exist
            resolvedTask.src = fs.realpathSync(path.resolve(buildOptions.root, task.src))
        } catch (e) {
            throw new Error(`Build task [${resolvedTask.use}] could not be resolved - folder src [${path.resolve(buildOptions.root, task.src)}] does not exist`)
        }
        resolvedTask.dest = path.resolve(buildOptions.target, task.dest || task.src)
        resolvedTask.buildOptions = buildOptions

        return resolvedTask
    }

    _getExistingTasks() {
        let tasks = []
        if (Array.isArray(this.env.build.tasks)) {
            tasks = this.env.build.tasks
        }
        return tasks
    }

    _ensureConsistentTaskSettings(tasks) {
        // do not modify existing tasks
        return tasks.map((task) => {
            task = Object.assign(task)
            task.options = task.options || {}
            if (!task.options.model || Array.isArray(task.options.model) && task.options.model.length === 0) {
                task.options.model = [task.src]
            } else if (!Array.isArray(task.options.model)) {
                task.options.model = [task.options.model]
            }
            if (!task.for && !task.use) {
                throw new Error(`Invalid build task defined for folder [${task.src}]`)
            }
            return task
        })
    }

    async _createTasksFromConfig(buildOptions) {
        this.logger.log("[cds] - Determining CDS build tasks from CDS configuration - applying defaults")

        let db = BuildTaskFactory._normalizePath(this.env.folders.db)
        let srv = BuildTaskFactory._normalizePath(this.env.folders.srv)
        const { root: projectPath } = buildOptions
        const defaultModels = this._getDefaultModelOptions(projectPath)
        const dbOptions = {
            model: [...defaultModels]
        }
        const srvOptions = {
            model: [...defaultModels]
        }
        const fioriSrvOptions = {
            model: [...defaultModels]
        }
        let tasks = []

        if (Array.isArray(db) && db.length > 0) {
            db = BuildTaskFactory._getModuleFolder(projectPath, db) || "db"
        }
        if (Array.isArray(srv) && srv.length > 0) {
            srv = BuildTaskFactory._getModuleFolder(projectPath, srv) || "srv"
        }
        if (fs.existsSync(path.resolve(projectPath, db))) {
            // create hana build task
            const dbTask = this._createDbTask(projectPath, db, dbOptions)
            if (dbTask) {
                tasks.push(dbTask)
            }
        } else {
            db = null
        }

        if (fs.existsSync(path.resolve(projectPath, srv))) {
            // create java or node build task
            const srvTask = this._createSrvTask(projectPath, srv, srvOptions)
            if (srvTask) {
                tasks.push(srvTask)
            }

            // create fiori build tasks
            const fioriTasks = this._createFioriTasks(projectPath, fioriSrvOptions)
            if (fioriTasks.length > 0) {
                const appDirs = this._getFioriAppModelPaths(projectPath, fioriTasks)
                srvOptions.model = BuildTaskFactory._pushModelPaths(projectPath, srvOptions.model, appDirs)
                dbOptions.model = BuildTaskFactory._pushModelPaths(projectPath, dbOptions.model, appDirs)
                tasks = tasks.concat(fioriTasks)
            }
        }

        // create mtx build task for node applications
        if (db && tasks.find(task => task.for === BUILD_TASK_NODE)) {
            const mtxTask = this._createMtxTask()
            if (mtxTask) {
                tasks.push(mtxTask)
            }
        }
        return tasks
    }

    _createDbTask(projectPath, src, options) {
        this.logger.log("[cds] - Determining database kind.")
        let task = null

        // legacy cds build generated hana artefacts by default - note: compat layer sets requires.db: {}
        if (!getProperty(this.env.requires, "db.kind") || this.env.requires.db.kind === "hana" || (this.env.requires.db.kind === "sql" && this.env.requires.db.use === "hana")) {
            this.logger.log("[cds] - Found HANA database.")
            // legacy build supports dest property
            const compileDest = getProperty(this.env, "data.dest")
            if (compileDest) {
                //../db/src/gen
                // compileDest is relative to src folder in modular build - resolve correctly
                options.compileDest = path.relative(path.resolve(projectPath, src), path.resolve(projectPath, compileDest))
            }

            task = {
                src: src,
                for: BUILD_TASK_HANA,
                options: options
            }
        } else {
            this.logger.log("[cds] - Found sqlite database - skipping HANA build task")
        }

        return task
    }

    _createMtxTask() {
        this.logger.log("[cds] - Determining single or multi-tenant strategy.")
        let task = null

        if (getProperty(this.env, "requires.db.kind") === "hana" && getProperty(this.env, "requires.db.multiTenant") === true) {
            this.logger.log("[cds] - Found multi-tenant app.")

            task = {
                src: ".",
                for: BUILD_TASK_MTX,
                dest: "srv"
            }
        } else {
            if (DEBUG) {
                this.logger.log("[cds] - Found single-tenant app - skipping mtx build task")
            }
        }
        return task
    }

    _createSrvTask(projectPath, src, options) {
        this.logger.log("[cds] - Determining implementation technology")
        let task = this._createJavaTask(projectPath, src, options)

        if (!task) {
            this.logger.log("[cds] - Found implementation technology node")
            task = {
                src: src,
                for: BUILD_TASK_NODE,
                options: options
            }
        }
        return task
    }

    _createJavaTask(projectPath, src, options) {
        if (this._hasJavaNature(projectPath, src)) {
            this.logger.log("[cds] - Found implementation technology java")
            // legacy build supports dest property
            const compileDest = getProperty(this.env, "service.dest")
            if (compileDest) {
                // compileDest is relative to src folder in modular build - resolve correctly
                options.compileDest = path.relative(path.resolve(projectPath, src), path.resolve(projectPath, compileDest))
            }
            return {
                src: src,
                for: BUILD_TASK_JAVA,
                options: options
            }
        }
        return null
    }

    _createFioriTasks(projectPath, fioriSrvOptions) {
        let tasks = []

        this.logger.log("[cds] - Determining fiori modules - matching modules */webapp/manifest.json")

        // fiori-app build-tasks
        let appDirs = this.env.ui && this.env.ui.apps ? this.env.ui.apps : undefined
        if (!appDirs) {
            const DEFAULT_UI_MANIFEST_PATTERNS = [
                "*/webapp/manifest.json" // top-level UI apps  (typical Web IDE layout)
            ]
            let app = BuildTaskFactory._normalizePath(this.env.folders.app)
            if (typeof app === "string") {
                DEFAULT_UI_MANIFEST_PATTERNS.push(path.join(app, "*/webapp/manifest.json"))
            } else if (Array.isArray(app)) {
                app.forEach(entry => DEFAULT_UI_MANIFEST_PATTERNS.push(path.join(entry, "*/webapp/manifest.json")))
            }

            const manifestPaths = BuildTaskFactory._findFiles(projectPath, DEFAULT_UI_MANIFEST_PATTERNS)

            // use '/' for any cds-config path entries
            appDirs = manifestPaths.map(manifestPath => path.relative(projectPath, manifestPath.split("webapp")[0]).replace(/\\/g, CDS_CONFIG_PATH_SEP))
        } else {
            appDirs = appDirs.map(appDir => {
                if (path.basename(appDir) === "webapp") {
                    return path.dirname(appDir)
                }
                return appDir
            })
        }

        this.logger.log(`[cds] - Found fiori app paths [${appDirs}]`)

        appDirs.forEach(appDir => {
            appDir = BuildTaskFactory._normalizePath(appDir)
            let modelPaths = this._resolve(path.resolve(projectPath, appDir))
            const newTask = {
                src: appDir,
                for: "fiori",
                options: {
                    model: BuildTaskFactory._pushModelPaths(projectPath, fioriSrvOptions.model, modelPaths.length > 0 ? [appDir] : [])
                }
            }
            if (!tasks.find((task) => {
                return task.src === newTask.src && task.for === newTask.for
            })) {
                tasks.push(newTask)
            }
        })

        return tasks
    }

    _getDefaultModelOptions(projectPath) {
        const rm = Object.values(this.env.requires).map(r => r.model).filter(m => m)
        return BuildTaskFactory._pushModelPaths(projectPath, [], this.env.roots, rm)
    }

    _getFioriAppModelPaths(projectPath, tasks) {
        const appDirs = []

        tasks.forEach((task) => {
            // the build task is only relevant if it contains an annotations model
            // only in that case options.model is containing an entry <task.src>
            if (task.for === BUILD_TASK_FIORI && task.options.model.find(cur => cur === task.src)) {
                const appRoot = task.src.split(CDS_CONFIG_PATH_SEP)[0]
                let appDir = task.src
                let model = this._resolve(path.resolve(projectPath, appRoot))
                if (model.length > 0) {
                    // appRoot may contain index.cds file
                    appDir = appRoot
                }

                if (appDir && !appDirs.find(cur => cur === appDir)) {
                    appDirs.push(appDir)
                }
            }
        })

        return appDirs
    }

    _resolve(modelPath) {
        let model
        try {
            model = this.cds.resolve(modelPath)
        } catch (e) {
            // silently ignore -> assume no model exists
        }

        return model ? model : []
    }

    /**
     * Returns <code>true</code> if this project is an old java service-sdk project,
     * <code>false</code> if it is a java-NG project or if no pom.xml has been found.
     * @param {string} projectPath - the absolute project path
     * @param {string} src - the folder name of the service module
     */
    async _isOldJavaStack(projectPath, src) {
        return isOldJavaStack([path.join(projectPath, src), projectPath])
    }

    /**
     * Returns whether this project is a java project or not.
     * @param {string} projectPath - the absolute project path
     * @param {string} src - the folder name of the service module
     */
    _hasJavaNature(projectPath, src) {
        return hasJavaNature([path.join(projectPath, src), projectPath])
    }


    static _pushModelPaths(projectPath, model, ...modelPaths) {
        model = new Set(model)
        // may contain nested arrays
        modelPaths = BuildTaskFactory._flatten(modelPaths)

        modelPaths.forEach(m => {
            if (m && !model.has(m) && !model.has(m + "/")) {
                const dir = path.resolve(projectPath, m)
                if (fs.existsSync(dir)) {
                    model.add(BuildTaskFactory._normalizePath(m))
                } else if (fs.existsSync(dir + FILE_EXT_CDS)) { //might be cds file name, compability to old build configs
                    model.add(m)
                }
            }
        })
        return [...model]
    }

    static _flatten(modelPaths) {
        return modelPaths.reduce((acc, m) => {
            if (Array.isArray(m)) {
                acc = acc.concat(BuildTaskFactory._flatten(m))
            } else if (m) {
                acc.push(m)
            }
            return acc
        }, [])
    }

    static _strippedPath(p) {
        return p.replace(/^(\/|\\)/, '').replace(/(\/|\\)$/, '') // strip leading and trailing slash or backslash
    }

    static _readDirs(dir) {
        if (!fs.existsSync(dir) || !fs.lstatSync(dir).isDirectory()) return []
        return fs.readdirSync(dir)
            .map(f => path.resolve(dir, f))
            .filter(f => fs.lstatSync(f).isDirectory())
    }

    static _findFiles(projectPath, patterns) {
        const files = []
        patterns.forEach(pattern => {
            const starIndex = pattern.indexOf('*')
            if (starIndex >= 0) {
                const dir = path.resolve(projectPath, pattern.substring(0, starIndex))
                const subPattern = BuildTaskFactory._strippedPath(pattern.substring(starIndex + 1, pattern.length)) // '*/foo/bar/' -> 'foo/bar'
                files.push(...BuildTaskFactory._readDirs(dir).map(subDir => BuildTaskFactory._findFiles(subDir, [subPattern])))
            } else {
                const file = path.resolve(projectPath, pattern)
                if (fs.existsSync(file)) files.push(file)
            }
        })

        function _flatten(o, arr = []) {
            if (o) {
                Array.isArray(o) ? o.forEach(e => _flatten(e, arr)) : arr.push(o)
            }
            return arr
        }

        return _flatten(files)
    }

    /**
     * For valid paths remove trailing '/'. Otherwise return as is - important!!
     * @param {*} dir
     */
    static _normalizePath(dir) {
        return typeof dir === "string" ? dir.replace(/\/$/, '') : dir
    }

    /**
     * Determines the module folder from the past list that may represent files or folders w or w/o .cds file extension.
     * @param {string} projectPath
     * @param {Array} filesOrFolders
     */
    static _getModuleFolder(projectPath, filesOrFolders) {
        const resources = [...filesOrFolders]
        filesOrFolders.forEach(fileOrFolder => {
            if (path.extname(fileOrFolder) !== FILE_EXT_CDS) {
                resources.push(fileOrFolder + FILE_EXT_CDS)
            }
        })
        return resources.reduce((acc, resource) => {
            if (!acc) {
                let resourcePath = path.resolve(projectPath, resource)
                if (fs.existsSync(resourcePath)) {
                    if (fs.lstatSync(resourcePath).isDirectory()) {
                        return resource
                    }
                    // represents file
                    resource = path.dirname(resource)
                    return resource !== "." ? resource : null
                }
            }
            return acc
        }, null)
    }

    // !!! has been used by cds-dk < 1.6.0 !!!
    static _isJavaServiceImpl(dir) {
        return hasJavaNature([dir, path.dirname(dir)])
    }
}

module.exports = BuildTaskFactory
