const fs = require('@sap/cds-foss')('fs-extra')
const path = require('path')
const _cds = require('../cds')
const cli = require('../../bin/utils/cli')

const { allSettled, BuildError, BuildRuntimeError, BuildMessage } = require('./util')
const { OUTPUT_MODE_DEFAULT, BUILD_TASK_USE_PREFIX, SEVERITES, LOG_LEVELS } = require('./constants')

const DEBUG = process.env.DEBUG
const COMPILATION_ERROR = 'CompilationError'
const COMPILE_MESSAGE = 'CompileMessage'

class BuildTaskEngine {
    constructor(logger, cds) {
        this._logger = logger || global.console
        this._cds = cds ? cds : _cds
    }

    get cds() {
        return this._cds
    }
    get env() {
        return this._cds.env
    }
    get logger() {
        return this._logger
    }

    async processTasks(tasks, buildOptions, clean = true) {
        const handlers = []
        const timerKey = "cds build completed in"
        this.logger.time(timerKey)

        if (buildOptions) {
            // clone as data may be stored as part of the buildOptions object
            buildOptions = Object.assign(buildOptions)
        } else {
            buildOptions = {
                root: process.cwd()
            }
        }
        if (!buildOptions.outputMode) {
            buildOptions.outputMode = OUTPUT_MODE_DEFAULT
        }

        this.logger.log(`[cds] - building project [${buildOptions.root}], clean [${clean}]`)
        const info = require('../../bin/version').info()
        this.logger.log(`\n[cds] - cds [${info['@sap/cds']}], compiler [${info['@sap/cds-compiler']}], home [${info.home}]`)

        if (!buildOptions.target) {
            buildOptions.target = path.resolve(buildOptions.root, this.env.build.target)
        }

        tasks.forEach((task) => {
            if (task) {
                const handler = this._createHandler(task, buildOptions)
                handlers.push(handler)
            }
        })

        // use resolved tasks
        buildOptions.tasks = handlers.map(handler => handler.task)

        try {
            await this._executePrepare(handlers)
            await this._executeCleanBuildTasks(handlers, buildOptions, clean)
            const buildResult = await this._executeBuildTasks(handlers, buildOptions)
            await this._logBuildOutput(handlers, buildOptions)
            this._logMessages(buildOptions, BuildTaskEngine._getHandlerMessages(handlers))
            this._logTimer(timerKey)

            return buildResult
        } catch (error) {
            await this._logBuildOutput(handlers, buildOptions, false)
            if (!buildOptions.cli) {
                this._logMessages(buildOptions, BuildTaskEngine._getErrorMessages([error]))
            }

            if (error.name === BuildError.name && error.errors.length > 0 && error.errors[0].constructor.name === COMPILATION_ERROR) {
                // TODO: for compatibility reasons with cds-mtx we're throwing the actual cause of type CompiliationError
                // Note: As a consequence we are loosing any info or warning messages issued by build task handlers
                throw error.errors[0]
            }
            throw error
        }
    }

    async _executePrepare(handlers) {
        const handlerGroups = new Map()

        // group handlers by type
        handlers.forEach(handler => {
            handlerGroups.has(handler.task.for) ? handlerGroups.get(handler.task.for).push(handler) : handlerGroups.set(handler.task.for, [handler])
        })

        const promises = []
        for (let handlerGroup of handlerGroups.values()) {
            promises.push(this._doPrepare(handlerGroup))
        }
        return Promise.all(promises)
    }

    async _doPrepare(handlerGroup) {
        for (let handler of handlerGroup) {
            const result = await handler.prepare()
            if (result === false) {
                break
            }
        }
    }

    async _executeCleanBuildTasks(handlers, buildOptions, clean) {
        if (clean) {
            // clean entire build staging folder once
            if (buildOptions.target !== buildOptions.root) {
                if (DEBUG) {
                    this.logger.log(`[cds] - clean staging folder ${buildOptions.target}`)
                }
                await fs.remove(buildOptions.target)
            }

            const results = await allSettled(handlers.map((handler) => {
                if (DEBUG) {
                    this.logger.log("[cds] - clean handler generation folder")
                    this._logTaskHandler(handler)
                }
                return handler.clean()
            }))
            // check for errors and throw exception
            this._resolveHandlerResponse(results, buildOptions)
        }
    }

    async _executeBuildTasks(handlers, buildOptions) {
        const results = await allSettled(handlers.map((handler) => {
            if (DEBUG) {
                this.logger.log("[cds] - build module")
                this._logTaskHandler(handler)
            }

            return handler.build()
                .then(handlerResult => {
                    return {
                        task: handler.task,
                        result: handlerResult,
                        messages: this._sortCompilationErrorsUnique(buildOptions, handler.messages)
                    }
                })
        }))
        // check for errors and throw exception - return results otherwise including any compiler and build status messages
        return this._resolveHandlerResponse(results, buildOptions, BuildTaskEngine._getHandlerMessages(handlers))
    }

    _resolveHandlerResponse(results, buildOptions, handlerMessages = []) {
        const errors = []
        const resolvedResults = results.reduce((acc, r) => {
            if (r.state === 'fulfilled') {
                acc.push(r.value)
            }
            if (r.state === 'rejected' && r.reason) {
                errors.push(r.reason)
            }
            return acc
        }, [])

        if (errors.length > 0) {
            const runtimeErrors = errors.filter(e => e.constructor.name !== COMPILATION_ERROR && e.name !== BuildError.name)
            if (runtimeErrors.length > 0) {
                throw new BuildRuntimeError(`CDS build failed for [${buildOptions.root}], internal error`, runtimeErrors)
            }
            const compileErrors = errors.filter(e => e.constructor.name === COMPILATION_ERROR)
            let buildErrors = []
            // NOTE: The order is important for now as for compatibility reasons the origin CompilationError
            // is thrown in processTasks method.
            // 1. compiler warnings are returned as handler messages
            const compileMessages = handlerMessages.filter(message => message.constructor.name === COMPILE_MESSAGE)
            if (compileErrors.length > 0) {
                const compileError = compileErrors[0]
                compileError.errors = this._sortCompilationErrorsUnique(buildOptions, BuildTaskEngine._getErrorMessages(compileErrors), compileMessages)
                buildErrors.push(compileError)
            }

            // 2. add other build errors
            buildErrors = buildErrors.concat(errors.filter(e => e.name === BuildError.name))

            // 3. add messages from build tasks
            buildErrors = buildErrors.concat(handlerMessages.filter(message => message.name === BuildMessage.name))

            throw new BuildError(`CDS build failed for [${buildOptions.root}]`, buildErrors)
        }
        return resolvedResults
    }

    _createHandler(task, buildOptions) {
        let resolvedTask = null

        try {
            resolvedTask = this._resolveTask(task, buildOptions)
            let modulePath = null

            if (resolvedTask.use.startsWith(BUILD_TASK_USE_PREFIX)) {
                modulePath = "./" + resolvedTask.use.split("/").pop()
            } else {
                // handle external build plugins
                modulePath = resolvedTask.use
            }

            const BuildTaskHandler = require(modulePath)

            if (DEBUG) {
                this.logger.log(`[cds] - loaded BuildTaskHandler [${resolvedTask.use}], module path [${modulePath}]`)
            }
            const handler = new BuildTaskHandler(resolvedTask, buildOptions)
            handler.cds = this.cds
            handler.logger = this.logger
            handler.init()
            if (DEBUG) {
                this.logger.log(`[cds] - created BuildTaskHandler [${resolvedTask.use}]`)
            }
            return handler
        } catch (e) {
            const error = new BuildRuntimeError(`Failed to create BuildTaskHandler [${resolvedTask ? resolvedTask.use : task.use || task.for}]`, [e])
            this.logger.error(`[cds] - ${error}`)
            throw error
        }
    }

    _resolveTask(task, buildOptions) {
        const resolvedTask = Object.assign({}, task)

        if (!resolvedTask.use) {
            if (resolvedTask.for) {
                resolvedTask.use = BUILD_TASK_USE_PREFIX + resolvedTask.for
            } else {
                throw new Error("Invalid build task configuration data - either task.use or task.for definition required")
            }
        } else {
            if (!resolvedTask.for) {
                resolvedTask.for = resolvedTask.use.split("/").pop()
            }
        }
        if (!resolvedTask.for) {
            resolvedTask.for = resolvedTask.use.split("/").pop()
        }

        try {
            // resolving sym-links, but be careful as realpathSync is throwing exception if directory does not exist
            resolvedTask.src = fs.realpathSync(path.resolve(buildOptions.root, task.src))
        } catch (e) {
            throw new Error(`Build task [${resolvedTask.use}] could not be resolved - folder src [${path.resolve(buildOptions.root, task.src)}] does not exist`)
        }
        resolvedTask.dest = path.resolve(buildOptions.target, task.dest || task.src)
        resolvedTask.buildOptions = resolvedTask.buildOptions || {}

        return resolvedTask
    }

    _getBuildOutput(handlers, buildOptions) {
        const files = handlers.reduce((acc, handler) => acc.concat(handler.files), []).sort()
        return files.map(file => path.relative(buildOptions.root, file))
    }

    async _logBuildOutput(handlers, buildOptions, writeOutputFile = true) {
        // log all generated files
        const files = this._getBuildOutput(handlers, buildOptions)

        if (files.length > 0) {
            this.logger.log('\n[cds] - done > wrote output to:')
            files.forEach((file) => {
                this.logger.log('  ' + file)
            })
        }

        if (writeOutputFile) {
            const outputFile = this.env.build.outputfile || process.env.GENERATION_LOG
            if (outputFile) {
                this.logger.log(`[cds] - writing generation log to [${outputFile}]`)
                await fs.outputFile(outputFile, files.join('\n'))
                    .catch((error) => {
                        this.logger.error(`[cds] - failed to write generation log`)
                        this.logger.error(error.stack || error)
                        return Promise.resolve()
                    })
            }
        }
    }

    _logTimer(timerKey) {
        this.logger.log("")
        this.logger.timeEnd(timerKey)
        this.logger.log("")
    }

    _logTaskHandler(handler) {
        this.logger.log(`[cds] - handler ${handler.name}`)
        this.logger.log(`[cds] - details src [${handler.stripProjectPaths(handler.task.src)}], dest [${handler.stripProjectPaths(handler.task.dest)}], use [${handler.task.use}], options [${JSON.stringify(handler.task.options)}]`) //NOSONAR
    }

    _logMessages(buildOptions, messages) {
        if (messages && messages.length > 0) {
            this.logger.log("")
            const options = {
                log: this.logger.log,
                "log-level": this._getLogLevel(buildOptions) // ensures that for tests the correct cds.env is used
            }
            cli.log(messages, options)
            this.logger.log("")
        }
    }

    /**
     * Returns a sorted and flatend list of all messages extracted from the given errors.
     * @param {Array<Error>} errors
     */
    static _getErrorMessages(errors) {
        let messages = []
        // flatten all compile messages in order to filter duplicates and sort later on
        errors.forEach(error => {
            if (Array.isArray(error.errors) && error.errors.length > 0) {
                messages = messages.concat(BuildTaskEngine._getErrorMessages(error.errors))
            } else {
                messages.push(error)
            }
        })
        return messages
    }

    /**
     * Returns compiler messages and validation messages issued by handlers.
     * @param {Array<BuildTaskHandler>} handlers
     */
    static _getHandlerMessages(handlers) {
        return handlers.reduce((acc, handler) => acc.concat(handler.messages), [])
    }

    /**
     * Sort and filter the given errors of type CompileMessage or BuildMessage according to their severity and location,
     * but leave any other errors untouched as part of the result array.<br>
     * The log level passed as 'buildOptions.log-level' or defined in 'cds.env' is used to filter the given messages.
     * @param {object} buildOptions
     * @param  {...Error} messages
     */
    _sortCompilationErrorsUnique(buildOptions, ...messages) {
        const comparator = BuildTaskEngine._compareErrorMessages
        const logLevelIdx = LOG_LEVELS.indexOf(this._getLogLevel(buildOptions))
        const filteredMessages = []
        // filter duplicates
        messages = messages.reduce((acc, m) => acc.concat(m), [])
        messages.forEach(message => {
            const hasDup = filteredMessages.some(v => comparator(v, message) === 0)
            if (!hasDup && (!message.severity || logLevelIdx >= SEVERITES.indexOf(message.severity))) {
                filteredMessages.push(message)
            }
        })
        return filteredMessages.sort(comparator)
    }

    static _compareErrorMessages(a, b) {
        function eq(x, y) {
            return (x === y) ? 0 : (x > y) ? 1 : -1
        }

        let rc = SEVERITES.indexOf(a.severity) - SEVERITES.indexOf(b.severity)
        if (rc !== 0) {
            return rc
        }

        rc = eq(a.message, b.message)
        if (rc !== 0) {
            return rc
        }

        if (a.location && b.location) {
            const aend = a.location.end || a.location.start;
            const bend = b.location.end || b.location.start;

            return (eq(a.location.filename, b.location.filename) ||
                eq(a.location.start.line, b.location.start.line) ||
                eq(a.location.start.column, b.location.start.column) ||
                eq(aend.line, bend.line) ||
                eq(aend.column, bend.column))
        }
        else {
            return (!a.location ? (!b.location ? 0 : 1) : -1)
        }
    }

    /**
     * Return user defined log level or default value 'warn'
     * @param {string} buildOptions
     */
    _getLogLevel(buildOptions) {
        return buildOptions["log-level"] || this.env["log-level"]
    }
}

module.exports = BuildTaskEngine
