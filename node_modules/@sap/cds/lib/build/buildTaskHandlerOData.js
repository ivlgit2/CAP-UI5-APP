const path = require('path')
const BuildTaskHandler = require('./buildTaskHandler')
const { BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY } = require('./constants')

class BuildTaskHandlerOData extends BuildTaskHandler {
    constructor(name, task, buildOptions) {
        super(name, task, buildOptions)
        this._result = {
            dest: task.dest,
            csn: {},
            edmx: new Map(),
            languages: new Set(),
            services: new Set()
        }
    }

    async compileCsn(model, csnDest) {
        // csn for service providers
        const options = this._options4odata()
        const csn = this.cds.compile.for.odata(model, options)
        this._result.csn = csn

        this.pushMessages(options.messages || options._messages)

        if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            await this.write(this.cds.compile.to.json(csn)).to(path.join(csnDest, 'csn.json'))
        }
    }

    async compileEdmx(model, edmxDest) {
        const promises = []
        const services = this.cds.reflect(model).all(this.cds.service)

        this._result.languages.add('')  // TODO mtx build_helper tests currently expects this, strange...
        if (services.length > 0) {
            const options = this._options4edmx()
            // new compile impl is throwing error in case no services exist!
            const result = this.cds.compile.to.edmx(model, options)
            this.pushMessages(options.messages || options._messages)

            if (result) {
                for (let [content, key] of result) {
                    const serviceName = key.file ? key.file : key.name
                    this._result.services.add(serviceName)
                    const locales = this.cds.localize(model, this.task.options.lang || ['all'], content)
                    for (let [localizedContent, { lang }] of locales) {
                        this._result.languages.add(lang)
                        const fileName = serviceName + (lang ? '_' + lang + '.xml' : '.xml')
                        this._result.edmx.set(fileName, localizedContent)

                        if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
                            promises.push(this.write(localizedContent).to(path.join(edmxDest, fileName)))
                        }
                    }
                }
            }
        }
        return Promise.all(promises)
    }

    collectBundles(sources) {
        // collect effective i18n properties...
        let bundles = {}
        const bundleGenerator = this.cds.localize.bundles4({
            _sources: sources
        })

        if (typeof bundleGenerator === "object" && bundleGenerator.next) {
            for (let [locale, bundle] of bundleGenerator) {
                // fallback bundle has the name ""
                if (typeof locale === 'string') {
                    bundles[locale] = bundle
                }
            }
        }

        // omit bundles in case the fallback bundle is the only existing entry
        const keys = Object.keys(bundles)
        if (keys.length === 1 && keys[0] === "" && Object.keys(bundles[keys[0]]).length === 0) {
            bundles = {}
        }
        return bundles
    }

    _options4odata() {
        const o = this.options()
        o.version = this.env.odata.version
        if (this.env.sql.names !== 'plain') {
            o.sql_mapping = this.env.sql.names
        }
        return o
    }

    _options4edmx() {
        const o = this._options4odata()
        o.service = 'all'
        return o
    }
}
module.exports = BuildTaskHandlerOData
