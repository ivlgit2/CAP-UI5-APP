const path = require('path')
const fs = require('@sap/cds-foss')('fs-extra')
const BuildTaskEngine = require('./buildTaskEngine')
const BuildTaskFactory = require('./buildTaskFactory')
const BuildTaskHandler = require('./buildTaskHandler')
const { BuildError, BuildRuntimeError } = require('./util')

module.exports = { build, BuildTaskFactory, BuildTaskEngine, BuildTaskHandler, BuildError, BuildRuntimeError }

/**
 * New modular build.
 *
 * @param {object} options - commmand options as defined by build command.
 * @param {object} _env - for testing purposes only, will be removed.
 */
async function build(options = {}, _env = null /* for unit tests only: */) {
    const logger = options.logger || global.console
    const projectPath = path.resolve(options.project || '.')

    if (!fs.lstatSync(projectPath).isDirectory()) {
        return Promise.reject(`Project [${projectPath}] does not exist`)
    }

    const cds = require('../cds').in(projectPath)
    if (_env) {
        // REVISIT: please avoid using internal APIs
        cds.env = cds.env._merge_with(_env)
    }

    if (cds.env.features.snapi === 'runtime-only') cds.env.features.snapi = false

    const buildOptions = {
        root: projectPath,
        "log-level": options["log-level"],
        cli: options.cli
    }
    if (cds.env.build.mode === "inplace") {
        cds.env.build.target = "."
    }

    let tasks

    // check for dedicated module build
    if (options.for || options.use) {
        const task = _createTaskFromCommandLine(options)
        tasks = task ? [task] : []
    } else {
        tasks = await new BuildTaskFactory(logger, cds).getTasks(buildOptions)
    }

    return new BuildTaskEngine(logger, cds).processTasks(tasks, buildOptions)
}

function _createTaskFromCommandLine(options) {
    let task = null

    // check for dedicated module build
    if (options.for || options.use) {
        // TODO generic command-line options -> JSON mapping
        let model
        if (Array.isArray(options["options-model"])) {
            model = options["options-model"]
        } else if (typeof options["options-model"] === "string") {
            model = options["options-model"].split(",").map((entry) => entry.trim())
        }

        task = {
            "src": options["src"],
            "options": {}
        }

        if (options["for"]) {
            task.for = options["for"]
        }
        if (options["use"]) {
            task.use = options["use"]
        }
        if (options["dest"]) {
            task.dest = options["dest"]
        }
        if (model) {
            task.options.model = model
        }
    }
    return task
}
