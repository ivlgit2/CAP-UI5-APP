'use strict';

/**
 * In the OData transformer, managed associations produce foreign keys.
 * If an association is also a primary key, the additionally created foreign keys become also primary keys in the parent artifact.
 * Proper FK generation requires specific order of performing that.
 * First non-PK association should be processed, then the PK associations.
 * This module provides functionality to sort managed associations depending on if they are marked as primary key or not.
 */

const {
  forEachDefinition,
  forEachMemberRecursively
} = require('../model/csnUtils');

function buildDependenciesFor(csn) {
  const toProcess={};
  const countOfKeyAssocs={};
  const unprocessedKeyAssocsCount={};

  function registerKeyAssociation(from, name, to) {
    initWithInteger(unprocessedKeyAssocsCount,from);
    initWithMap(countOfKeyAssocs,from);
    countOfKeyAssocs[from][name]=to;
    unprocessedKeyAssocsCount[from]++;
  }

  function setToDo(what) {
    initWithInteger(unprocessedKeyAssocsCount,what);
    toProcess[what]=true;
  }

  function setDone(what) {
    toProcess[what]=false;
  }

  function setUnprocessedKeyAssocCount(artifact, count) {
    unprocessedKeyAssocsCount[artifact]=count;
  }

  function getUnprocessedKeyAssocCount(artifact) {
    return unprocessedKeyAssocsCount[artifact];
  }

  let result=[]; // list of sorted artifact names

  // loop over definitions and their elements to find PK associations
  forEachDefinition(csn, (def, defName) => {
    let hasKeyAssociations=false;
    forEachMemberRecursively(def, (member, memberName) => {
      // go through only managed associations and compositions
      if(isAssociationOrComposition(member) && !member.on) {
        setToDo(defName);
        if(member.key) {
          registerKeyAssociation(defName, memberName, member.target);
          hasKeyAssociations=true;
        }
      }
    }) // forEachMemberRecursively
    if(!hasKeyAssociations) {
      result.push(defName)
      setDone(defName)
    }
  }) // forEachDefinition

  // Is there anything to process?
  let totalCountOfArtifactsToProcess=Object.keys(toProcess).length;
  if(totalCountOfArtifactsToProcess === 0) {
    return result; // nothing to do -> return
  }

  function processArtifacts() {
    let countOfProcessedArtifacts=0;
    for(let artifact in toProcess) {
      if(getUnprocessedKeyAssocCount(artifact)==0) {
        if(result.includes(artifact))
          continue;
        result.push(artifact)
        setDone(artifact)
        countOfProcessedArtifacts++;
      }
    }
    return countOfProcessedArtifacts;
  }

  function prepareArtifactsToProcess() {
    let hasMoreToProcess=false;
    for(let artifact in countOfKeyAssocs) {
      let aRed = countOfKeyAssocs[artifact];
      let stillToProcessCount = 0;
      for(let memberName in aRed) {
        let target = aRed[memberName];
        if(toProcess[target])
          stillToProcessCount++;
      }
      if(stillToProcessCount!=getUnprocessedKeyAssocCount(artifact)) {
        hasMoreToProcess=true;
        setUnprocessedKeyAssocCount(artifact,stillToProcessCount);
      }
    }
    return hasMoreToProcess;
  }

  let loops=0;
  do {
    // algorithm consistency check: can not process more artifacts than provided (prevent endless loop)
    if(loops>totalCountOfArtifactsToProcess)
      throw Error(`Error in sortByAssociationDependency: too many loops: ${loops}, expected at most: ${totalCountOfArtifactsToProcess}`);
    let countOfProcessed = processArtifacts();
    // consistency check: it should process at least one artifact (prevent endless loop)
    if(countOfProcessed==0 && loops>0)
      throw Error('Error in sortByAssociationDependency: processArtifacts did not process any artifacts');
    loops++;
  } while(prepareArtifactsToProcess());

  return result;
}

// ------------------------ helper functions ------------------------------------

// Return true if 'artifact' has an association type
function isAssociation(artifact) {
  return (artifact.type === 'cds.Association' || artifact.type === 'Association');
}

// Return true if 'artifact' has a composition type
function isComposition(artifact) {
  return (artifact.type === 'cds.Composition' || artifact.type === 'Composition')
}

function isAssociationOrComposition(artifact) {
  return isAssociation(artifact) || isComposition(artifact);
}

function initWithMap(what,name) {
  if(what[name]===undefined) what[name] = {};
}

function initWithInteger(what,name) {
  if(what[name]===undefined) what[name] = 0;
}

module.exports = buildDependenciesFor

