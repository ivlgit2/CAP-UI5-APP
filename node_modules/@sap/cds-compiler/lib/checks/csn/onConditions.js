'use strict';

// Only to be used with validator.js - a correct this value needs to be provided!

/**
 * Prepare the ref steps so that they are loggable
 *
 * @param {any} refStep part of a ref
 * @returns {string}
 */
function logReady(refStep){
  return refStep.id || refStep;
}

/**
 * Check that the other side of the comparison is a valid $self backlink
 *
 * - operator "="
 * - nothing but "$self", no further steps
 *
 * @param {Object[]} on On-Condition
 * @param {Number} startIndex Index of the current expression to "look around"
 * @returns {boolean}
 */
function otherSideIsValidDollarSelf(on, startIndex){
  if(on[startIndex-1] && on[startIndex-1] === '='){
    if(on[startIndex-2]){
      const ref = on[startIndex-2].ref;
      return ref && ref.length === 1 && ( ref[0] === '$self' || ref[0] === '$projection' );
    } else {
      return false;
    }
  } else if(on[startIndex+1] && on[startIndex+1] === '='){
    if(on[startIndex+2]){
      const ref = on[startIndex+2].ref;
      return ref && ref.length === 1 && ( ref[0] === '$self' || ref[0] === '$projection' );
    } else {
      return false;
    }
  } else {
    return false;
  }
}

/**
 * Validate an on-condition
 *
 * - no traversal of unmanaged associations
 * - only use managed associations to access their foreign keys
 * - no filters
 * - no parameters
 * - must end in scalar type - unless $self comparison
 *
 * @param {object} member Member
 * @param {string} memberName Name of the member
 * @param {string} property Current property (part of forEachMember)
 * @param {Array} path CSN Path to current member
 */
function validateOnConditions(member, memberName, property, path){
  if(member && member.on){
    for(let i = 0; i < member.on.length; i++){
      if(member.on[i].ref){
        const ref = member.on[i].ref;
        const { _links, _art, $scope } = member.on[i];
        if(!_links) continue;
        const validDollarSelf = otherSideIsValidDollarSelf(member.on, i);
        for(let j = 0; j < _links.length-1; j++){
          if(_links[j].art.target && !((_links[j].art === member) || ref[j] === '$self' || ref[j] === '$projection' || validDollarSelf)){
            if(_links[j].art.on){
              // It's an unmanaged association - traversal is always forbidden
              this.signal(this.error`ON-Conditions can not follow unmanaged associations, step "${logReady(ref[j])}" of path ${ref.map(ps => `"${logReady(ps)}"`).join('.')}.`, path.concat(['on', i, 'ref', j]));
            } else {
              // It's a managed association - access of the foreign keys is allowed
              const nextRef = ref[j+1].id || ref[j+1];
              if(!_links[j].art.keys.some(ref => ref.ref[0] === nextRef)){
                this.signal(this.error`ON-Conditions can only follow managed associations to the foreign keys of the managed association, step "${logReady(ref[j])}" of path ${ref.map(ps => `"${logReady(ps)}"`).join('.')}.`, path.concat(['on', i, 'ref', j]));
              }
            }
          }

          if(ref[j].where){
            this.signal(this.error`ON-Conditions must not contain filters, step "${logReady(ref[j])}" of path ${ref.map(ps => `"${logReady(ps)}"`).join('.')}.`, path.concat(['on', i, 'ref', j]));
          }

          if(ref[j].args){
            this.signal(this.error`ON-Conditions must not contain parameters, step "${logReady(ref[j])}" of path ${ref.map(ps => `"${logReady(ps)}"`).join('.')}.`, path.concat(['on', i, 'ref', j]));
          }
        }
        if(_art && $scope !== '$self'){
          if(_art.elements || (_art.target && !validDollarSelf)){
            this.signal(this.error`The last path of an on-condition must be a scalar value, path ${ref.map(ps => `"${logReady(ps)}"`).join('.')} .`, path.concat(['on', i,'ref',ref.length-1]))
          } else if(_art.type && _art.type.ref){ // type of
            const typeArt = this.artifactRef(_art.type);
            const type = this.csn.definitions[this.effectiveType(typeArt.type)];
            if(type && (type.elements || (type.target && !validDollarSelf))){
              this.signal(this.error`The last path of an on-condition must be a scalar value, path ${ref.map(ps => `"${logReady(ps)}"`).join('.')} .`, path.concat(['on', i,'ref',ref.length-1]))
            }
          } else if(_art.type) { // type T
            const type = this.csn.definitions[this.effectiveType(_art.type)];
            if(type && (type.elements || (type.target && !validDollarSelf))){
              this.signal(this.error`The last path of an on-condition must be a scalar value, path ${ref.map(ps => `"${logReady(ps)}"`).join('.')} .`, path.concat(['on', i,'ref',ref.length-1]))
            }
          } else if(_art.items){
            this.signal(this.error`ON-Conditions can not use array-like elements, path ${ref.map(ps => `"${logReady(ps)}"`).join('.')}.`, path.concat(['on', i, 'ref', ref.length-1]));
          }
        }
      }
    }
  }
}

module.exports = validateOnConditions;
