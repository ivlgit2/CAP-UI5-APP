'use strict';

const alerts = require('../base/alerts');
const { getMessageFunction } = require('../base/messages');
const { hasArtifactTypeInformation } = require('../model/modelUtils')

// Semantic checks that are performed on artifacts

// Check that artifact 'art' is not empty and does not contain only virtual elements
// (not applicable to abstract artifacts)
function checkNotEmptyOrOnlyVirtualElems(art, model) {
  const { info, signal } = alerts(model);
  if (!art.abstract && emptyOrOnlyVirtualElements(art)) {
    const location = art.name && art.name.location || art.location;
    if (art.kind === 'entity')
      signal(info`Dubious entity without non-virtual elements`, location, undefined, 'empty-entity');
    else if (art.kind === 'type')
      signal(info`Dubious type without non-virtual elements`, location, undefined, 'empty-type');
  }

  // Return true if artifact or element 'construct' is a virtual element or an empty structure
  // or a structure that (recursively) is empty or only contains virtual elements
  function emptyOrOnlyVirtualElements(construct) {
    // Structured type ?
    if ((construct._finalType || construct).elements) {
      construct = construct._finalType || construct;
      // No elements or all elements recursively empty, too ?
      return construct.elements.length == 0
          || Object.keys(construct.elements).map(k => construct.elements[k]).every(elm => emptyOrOnlyVirtualElements(elm));
    }
    // Non-structured type - just check for virtual-ness or non-existing elements for entities or views
    return construct.virtual || (( construct.kind === 'entity' || construct.kind === 'view' ) && construct.elements === undefined );
  }
}

// Check that queries in 'art' do not contain unmanaged associations in GROUP BY or ORDER BY
function checkNoUnmanagedAssocsInGroupByOrderBy(art, model) {
  const { error, signal } = alerts(model);
  for (let query of art.$queries || []) {
    for (let groupByEntry of query.groupBy || []) {
      if (groupByEntry._artifact && groupByEntry._artifact._finalType && groupByEntry._artifact._finalType.onCond) {
        // Unmanaged association - complain
        signal(error`"${art.name.absolute}": Unmanaged associations are not allowed in GROUP BY`, groupByEntry.location);
      }
    }
    for (let orderByEntry of query.orderBy || []) {
      if (orderByEntry.value && orderByEntry.value._artifact && orderByEntry.value._artifact._finalType && orderByEntry.value._artifact._finalType.onCond) {
        // Unmanaged association - complain
        signal(error`"${art.name.absolute}": Unmanaged associations are not allowed in ORDER BY`, orderByEntry.value.location);
      }
    }
  }
}

/**
 * If the given artifact is a type definition then check whether it is
 * properly defined and has valid type information, e.g. information about
 * its elements or references another valid type.
 *
 * @param {XSN.Definition} artifact
 * @param {XSN.Model} model
 */
function checkTypeDefinitionHasType(artifact, model) {
  if (artifact.kind !== 'type')
    return;

  checkArtifactHasProperType(artifact, model);
}

/**
 * Check that the given artifact has proper type information.
 * Either the artifact itself is a proper type or its `type` property
 * references a proper type (including `many type of`).
 *
 * @param {XSN.Definition} artifact
 * @param {XSN.Model} model
 */
function checkArtifactHasProperType(artifact, model) {
  function warnAboutMissingType(art) {
    // Can happen in CSN, e.g. `{ a: { kind: "type" } }` but should
    // not happen in CDL.
    const message = getMessageFunction(model);
    message('check-proper-type', art.location, art, { art: artifact },
            ['Error'], {
              std: 'Dubious type $(ART) without type information',
              element: 'Dubious element $(MEMBER) of $(ART) without type information',
            });
  }

  if (!hasArtifactTypeInformation(artifact)) {
    warnAboutMissingType(artifact);
    return;
  }

  // Check for `type of`
  if (artifact.type) {
    checkTypeOfHasProperType(artifact, model)
    return;
  }

  const items = artifact.items;
  if (!items)
    return;

  // `array of` without nested `type of`
  if (!hasArtifactTypeInformation(items))
    warnAboutMissingType(items);

  else if (items && items.type)
    // `array of type of`
    checkTypeOfHasProperType(items, model)
}

/**
 * Check that the `type of` information in the given artifact (i.e. `type` property)
 * has proper type information or warn otherwise. The artifact's final type is checked.
 *
 * @param {XSN.Artifact} artifact
 * @param {XSN.Model} model
 */
function checkTypeOfHasProperType(artifact, model) {
  if (!artifact.type)
    return;

  const finalType = artifact.type._artifact && artifact.type._artifact._finalType;
  if (finalType && !hasArtifactTypeInformation(finalType)) {
    const message = getMessageFunction(model);
    message('check-proper-type-of', artifact.type.location, artifact, { art: artifact.type },
            'Info', {
              std: 'Referred type of $(ART) does not contain proper type information',
              element: 'Referred element $(MEMBER) of $(ART) does not contain proper type information',
            });
    return;
  }
}

module.exports = {
  checkNotEmptyOrOnlyVirtualElems,
  checkNoUnmanagedAssocsInGroupByOrderBy,
  checkTypeDefinitionHasType,
  checkTypeOfHasProperType,
  checkArtifactHasProperType,
};
